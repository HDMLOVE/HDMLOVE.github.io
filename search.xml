<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos+hexo搭建个人网站</title>
    <url>/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;花了好几天，熬了几个夜晚，终于把自己的个人博客搭建起来了网站，顺便来一篇教程，分享给大家，同时也方便以后再次部署。我之前是在github上搭建了一版，github+hexo,奈何实在太卡了，想起自己在阿里云有台服务器，然后直接部署到云上了,下面方法步骤亲测成功。</p>
<h1 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h1><blockquote>
<ul>
<li>一台个人PC</li>
<li>money!(开玩笑的 ^-^)</li>
<li>一台linux服务器，可以买台云服务器，没有又想体验的话就VM虚拟机，本地看看过把瘾吧。^ ^</li>
</ul>
</blockquote>
<h1 id="需要的软件环境"><a href="#需要的软件环境" class="headerlink" title="需要的软件环境"></a>需要的软件环境</h1><blockquote>
<ul>
<li>Git</li>
<li>Node.js</li>
<li>hexo-cli</li>
<li>Nginx</li>
</ul>
</blockquote>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p><a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a><br>下一步下一步傻瓜式安装</p>
<h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>下一步下一步傻瓜式安装</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><img src="/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/image1.jpg" alt="点击图片时候下方显示描述"></p>
<p>&ensp;&ensp;&ensp;&ensp;选择一个文件夹作为你的博客文件夹，比如我自己建立在E:盘在命令行窗口下：</p>
<p><img src="/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/image2.jpg" alt="点击图片时候下方显示描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v     # 查看hexo安装成功没</span><br><span class="line">cd e:       # 打开e盘;</span><br><span class="line">mkdir blog; # 创建blog文件夹作为我的博客目录</span><br><span class="line">cd blog     # 进入blog目录</span><br><span class="line">hexo init   # 初始化blog</span><br><span class="line">hexo g      # 生成静态页面</span><br><span class="line">hexo s      # 启动服务监听</span><br><span class="line">打开页面    localhost:4000</span><br><span class="line">可以看到hello world 的页面，初步完成。</span><br><span class="line"></span><br><span class="line">常用命令</span><br><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line"></span><br><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/02/28/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="linux下常用的一下命令"><a href="#linux下常用的一下命令" class="headerlink" title="linux下常用的一下命令"></a><strong>linux下常用的一下命令</strong></h1><h2 id="防火墙相关的命令。"><a href="#防火墙相关的命令。" class="headerlink" title="防火墙相关的命令。"></a><strong>防火墙相关的命令。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;4400-4600&#x2F;udp --permanen(指定端口范围为4400-4600通过防火墙)</span><br><span class="line"> 其中：</span><br><span class="line">--zone #作用域 </span><br><span class="line">--add-port&#x3D;80&#x2F;tcp #添加端口，格式为：端口&#x2F;通讯协议 </span><br><span class="line">--permanent #永久生效</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone&#x3D;public --remove-port&#x3D;80&#x2F;tcp --permanent（关闭指定端口）</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone&#x3D;public --list-ports（查看通过的端口）</span><br><span class="line"></span><br><span class="line">firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span><br></pre></td></tr></table></figure>
<h2 id="yum安装软件包。"><a href="#yum安装软件包。" class="headerlink" title="yum安装软件包。"></a><strong>yum安装软件包。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release #安装&quot;epel-release&quot;的软件包</span><br><span class="line">yum install tcpreplay</span><br></pre></td></tr></table></figure>
<h2 id="ps命令。"><a href="#ps命令。" class="headerlink" title="ps命令。"></a><strong>ps命令。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -eLf	 #查看进程线程情况</span><br></pre></td></tr></table></figure>
<h2 id="压缩、解压命令。"><a href="#压缩、解压命令。" class="headerlink" title="压缩、解压命令。"></a><strong>压缩、解压命令。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压缩：</span><br><span class="line">tar -zcvf &#x2F;tmp&#x2F;etc.tar.gz  &#x2F;etc     #将&#x2F;etc下的所有文件及目录打包到&#x2F;etc，并使用gz压缩  </span><br><span class="line">tar -cvf &#x2F;home&#x2F;abc.tar &#x2F;home&#x2F;abc    #只打包，不压缩</span><br><span class="line">tar -zcvf &#x2F;home&#x2F;abc.tar.gz &#x2F;home&#x2F;abc#打包，并用gzip压缩</span><br><span class="line"></span><br><span class="line">解压：</span><br><span class="line">tar -zxvf &#x2F;tmp&#x2F;etc.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="服务的锁定与取消。"><a href="#服务的锁定与取消。" class="headerlink" title="服务的锁定与取消。"></a><strong>服务的锁定与取消。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl mask firewalld   #需要锁定该服务时执行</span><br><span class="line">systemctl unmask firewalld #实现取消服务的锁定</span><br></pre></td></tr></table></figure>
<h2 id="路由配置相关。"><a href="#路由配置相关。" class="headerlink" title="路由配置相关。"></a><strong>路由配置相关。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#添加IPV6地址</span><br><span class="line">ip -6 addr add &lt;ipv6address&gt;&#x2F;&lt;prefixlength&gt; dev &lt;interface&gt;</span><br><span class="line">ip -6 addr add 2001:0db8:0:f101::1&#x2F;64 dev eth0</span><br><span class="line"></span><br><span class="line">ifconfig &lt;interface&gt; inet6 add &lt;ipv6address&gt;&#x2F;&lt;prefixlength&gt;</span><br><span class="line">ifconfig eth0 inet6 add 2001:0db8:0:f101::1&#x2F;64</span><br><span class="line"></span><br><span class="line">#添加默认路由</span><br><span class="line">ip -6 route add &lt;ipv6network&gt;&#x2F;&lt;prefixlength&gt; via &lt;ipv6address&gt;</span><br><span class="line">ip -6 route add default via 2001:0db8:0:f101::1</span><br><span class="line"></span><br><span class="line">route -A inet6 add &lt;ipv6network&gt;&#x2F;&lt;prefixlength&gt; gw</span><br><span class="line">route -A inet6 add default gw 2001:0db8:0:f101::1</span><br><span class="line"></span><br><span class="line">#查看路由</span><br><span class="line">ip -6 route show</span><br><span class="line">route -A &#39;inet6&#39;</span><br><span class="line">route -6</span><br><span class="line"></span><br><span class="line">#windows查看路由表</span><br><span class="line">route print</span><br><span class="line"></span><br><span class="line">#查看邻居缓存</span><br><span class="line">ip -6 neighbor show</span><br><span class="line"></span><br><span class="line">#windows查看邻居缓存</span><br><span class="line">netsh interface ipv6 show neighbors</span><br><span class="line"></span><br><span class="line">#查看smtp服务器</span><br><span class="line">ping smtp.sohu.com </span><br><span class="line">ping smtp.qq.com</span><br></pre></td></tr></table></figure>
<h2 id="更新内核命令。"><a href="#更新内核命令。" class="headerlink" title="更新内核命令。"></a><strong>更新内核命令。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update kernel -y</span><br></pre></td></tr></table></figure>
<h2 id="大文件重定向有效信息。"><a href="#大文件重定向有效信息。" class="headerlink" title="大文件重定向有效信息。"></a><strong>大文件重定向有效信息。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">重定向dmesg.txt关键字Call Trace的前后2000行到nn.txt：</span><br><span class="line">grep -C 2000 ‘Call Trace’ dmesg.txt &gt;nn.txt</span><br></pre></td></tr></table></figure>
<h2 id="Shell递归删除指定字符串文件或者目录。"><a href="#Shell递归删除指定字符串文件或者目录。" class="headerlink" title="Shell递归删除指定字符串文件或者目录。"></a><strong>Shell递归删除指定字符串文件或者目录。</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件：find . -name &quot;*.rej&quot; | xargs rm -rf</span><br><span class="line">目录：find . -type d -name &quot;*.rej&quot; | xargs rm -rf</span><br></pre></td></tr></table></figure>
<h2 id="文件夹建立软链接（用绝对地址）"><a href="#文件夹建立软链接（用绝对地址）" class="headerlink" title="文件夹建立软链接（用绝对地址）"></a><strong>文件夹建立软链接（用绝对地址）</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s 源地址 目的地址   #比如我把linux文件系统rootfs_dir软链接到&#x2F;home&#x2F;jyg&#x2F;目录下</span><br><span class="line">ln -s &#x2F;opt&#x2F;linux&#x2F;rootfs_dir  &#x2F;home&#x2F;jyg&#x2F;rootfs_dir #就可以了</span><br></pre></td></tr></table></figure>
<h2 id="大文件分割"><a href="#大文件分割" class="headerlink" title="大文件分割"></a><strong>大文件分割</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows下 d:&gt;wireshark&gt;editcap -C 1000000(文件大小) 待分割文件路径 新文件名称</span><br><span class="line">linux 可使用split命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Google浏览器无法安装问题</title>
    <url>/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/image1.jpg" alt="点击图片时候下方显示描述"></p>
<p>&ensp;&ensp;&ensp;&ensp;今天遇到一个有趣的问题，Google浏览器莫名其面的一直安装不上，自己捣鼓了好久最后才解决。网上有很多方法说是因为注册表有残留，准确的说是GoogleUpdate这个东西在作怪，解决的方法只需要将注册表里Google相关的东西删除。</p>
<h1 id="1、打开注册表直接Win-R输入regedit"><a href="#1、打开注册表直接Win-R输入regedit" class="headerlink" title="1、打开注册表直接Win+R输入regedit"></a>1、打开注册表直接Win+R输入regedit</h1><p><img src="/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/image2.jpg"></p>
<h1 id="2、删除注册表残留数据。"><a href="#2、删除注册表残留数据。" class="headerlink" title="2、删除注册表残留数据。"></a>2、删除注册表残留数据。</h1><p>&ensp;&ensp;&ensp;&ensp;删除\HKEY_CURRENT_USER\Software\和HKEY_LOCAL_MACHINE\SOFTWARE目录下的Google及对应的子目录就可以了。但是我操作的时候出现了问题，删除Google目录时候报错，后面发现是权限问题。解决方法：右键该目录修改管理员权限可以删除。</p>
<h1 id="3、确认电脑系统版本。"><a href="#3、确认电脑系统版本。" class="headerlink" title="3、确认电脑系统版本。"></a>3、确认电脑系统版本。</h1><p>&ensp;&ensp;&ensp;&ensp;可以删除之后还是发现无法安装，最后发现照着网上的帖子没有用，因为帖子估计都比较老，我的是win10系统，所以导致删除的路径不对，导致依旧无法正常安装，需要删除对应的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位：HKEY_LOCAL_MACHINE\SOFTWARE\Google</span><br><span class="line">64位：HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google</span><br></pre></td></tr></table></figure>
<h1 id="4、重启安装应用。"><a href="#4、重启安装应用。" class="headerlink" title="4、重启安装应用。"></a>4、重启安装应用。</h1><p>&ensp;&ensp;&ensp;&ensp;重新双击运行安装应用程序，完美解决！</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言error错误处理</title>
    <url>/2021/02/01/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Go语言错误处理"><a href="#Go语言错误处理" class="headerlink" title="Go语言错误处理"></a>Go语言错误处理</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 封装Go 防止野生的goruntime panic导致程序挂掉 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(x <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		x()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;he&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;lpyuan2&quot;</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;lpyuan1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="第3章-基本的数据类型"><a href="#第3章-基本的数据类型" class="headerlink" title="第3章 基本的数据类型"></a>第3章 基本的数据类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">四大类型：</span><br><span class="line">1、基础数据类型(basic type)</span><br><span class="line">2、聚合类型(aggregate type)</span><br><span class="line">3、引用类型(reference type)</span><br><span class="line">4、接口类型(interface type)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基础的数据类型：</span><br><span class="line">1、数字、字符串、布尔型</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux非阻塞模式下的EAGIN异常</title>
    <url>/2021/02/18/Linux%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84EAGIN%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>之前在写一个并发聊天室时候在多个客户端连续发送数据的时候遇到EAGIN错误，如图。</p>
<p>![image-20210218161957083](/Users/xiaoluo/Library/Application Support/typora-user-images/image-20210218161957083.png)</p>
<p>Linux下，管道、FIFO以及一些设备（通常是终端和网络）一般有以下几种性质。</p>
<blockquote>
<p>1、一次read操作返回的数据可能会少于所要求的数据，及时此时没有到达文件尾部也可能会出现这种情况。对于这种情况，我们不认为是错误，而是视为一种异常，应该继续对此设备进行读取。</p>
<p>2、一次write或send操作的返回值也可能会少于指定的输出的字节数。通常这可能是由于某一种因素引起的，比如在处理网络数据的时，内核输出的缓冲区满，此时写不进数据。我们也通常不认为这是一种错误，应当继续将余下的数据进行写入。（通常遇到这种情况的场景是非阻塞描述符，或者捕捉到某一种信号的时候，才会发生中途返回。）</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Mysql数据库</title>
    <url>/2020/02/29/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Raft算法</title>
    <url>/2021/01/07/Raft%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><h2 id="什么是Raft算法"><a href="#什么是Raft算法" class="headerlink" title="什么是Raft算法"></a>什么是Raft算法</h2><p>Raft算法是Multi-Paxos算法，</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本笔记</title>
    <url>/2020/02/29/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1、Shell脚本相关知识。"><a href="#1、Shell脚本相关知识。" class="headerlink" title="1、Shell脚本相关知识。"></a>1、<strong>Shell脚本相关知识。</strong></h1>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>windows安装向导脚本</title>
    <url>/2020/03/01/windows%E5%AE%89%E8%A3%85%E5%90%91%E5%AF%BC%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>一、windows 安装向导可以将程序打包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/01/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>十大经典排序算法为：冒泡，选择，插入、希尔、归并、快速、堆、计数、桶、基数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int a[] &#x3D; &#123;5,4,9,8,7,6,0,1,3,2&#125;;</span><br><span class="line">    prin_array(a, sizeof(a)&#x2F;sizeof(a[0])); </span><br><span class="line">    int len &#x3D; sizeof(a)&#x2F;sizeof(a[0]);</span><br><span class="line">    &#x2F;&#x2F; BubbleSort(a, sizeof(a)&#x2F;sizeof(a[0]));</span><br><span class="line">    SelectSort(a, sizeof(a)&#x2F;sizeof(a[0]));</span><br><span class="line">    prin_array(a, sizeof(a)&#x2F;sizeof(a[0]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>1、比较相邻的两个元素，如果第一个比第二个大，就交换他们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BubbleSort(int array[], int len)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j &#x3D; 0; j &lt; len-1-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[j] &gt; array[j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(&amp;array[j], &amp;array[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SelectSort(int array[], int len)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int min, index;</span><br><span class="line">    for ( i &#x3D; 0; i &lt; len-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min &#x3D; array[i];</span><br><span class="line">        &#x2F;* code *&#x2F;</span><br><span class="line">        for ( j &#x3D; i+1; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (min &gt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min &#x3D; array[j];</span><br><span class="line">                index &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Swap(&amp;array[i], &amp;array[index]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InsertSort(int array[], int len)&#123;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line">    int temp;</span><br><span class="line">    for ( i &#x3D; 1; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp &#x3D; array[i];</span><br><span class="line">        for ( j &#x3D; i-1; j &gt;&#x3D;0; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;* code *&#x2F;</span><br><span class="line">            if (temp &lt; array[j])&#123;</span><br><span class="line">                array[j+1] &#x3D; array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        array[j+1] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/2020/12/20/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;我们可以将标准输入、套接字等都看做IO的一路，多路复用的意思是在任何一路IO有事件的情况下，通知应用程序去处理相应的IO事件，这样程序就仿佛可以同一时刻处理多个IO事件了。</p>
</blockquote>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><blockquote>
<ul>
<li><p>select fd_set结构，底层是一个bitmap结构，是定长的1024，不容易改，如果需要改需要重新编译内核代码。</p>
</li>
<li><p>使用select函数，通知内核挂起进程，当一个或者多个IO事件发生之后，控制权限返回给应用程序，由应用程序进行IO事件的处理。</p>
</li>
<li><p>当有事件发生的时候，并不知道具体是哪几条流（可能有一个也可能有多个），只能轮询一遍出所有的流，找出相应的数据，或者写入数据的流，**时间复杂度为O(n)**。</p>
</li>
<li><p>需要维护一个存放大量fd的数据结构，当用户空间向内核空间传递该数据结构的时候会发生大量的拷贝，拷贝开销大，从而影响效率。</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *expectset, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">/* 秒 */</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;		<span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;</span><br><span class="line">timeout可以有三种情况：</span><br><span class="line">timeout == <span class="literal">NULL</span>;	<span class="comment">/* 等待无限长的时间 */</span></span><br><span class="line">timeout-&gt;tv_sec == <span class="number">0</span> &amp;&amp; timeout-&gt;tv_usec == <span class="number">0</span>	<span class="comment">/* 不等待，直接返回。（Noblock 非阻塞）*/</span></span><br><span class="line">timeout-&gt;tv_sec != <span class="number">0</span> || timeout-&gt;usec != <span class="number">0</span>	<span class="comment">/* 等待指定的时间 */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* FD_ZERO 将一个fd_set类型的变量的所有的位都设置为0 */</span></span><br><span class="line"><span class="keyword">int</span> FD_ZERO(fd_set *fdset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_CLR 可以将某一个位进行清除 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(fd_set *fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_SET 用来将某一个位进行置位1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_ISSET 用来检测某一个位是否被置位 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回值（return value）:做好准备的文件描述符个数，超时为0， 错误为-1。</p>
<p>中间的三个参数readset、writeset、exepectset，分别是读描述符集合 readset、写描述符集合 writeset 和异常描述符集合 exceptset，这些参数指明了我们关心哪一些描述符，和需要满足什么条件。一个文件描述符保存在fd_set类型之中，fd_set其实就是一个位图bitmap。</p>
<p>int maxfd; 指的是最大的文件描述符加1。</p>
<p>Linux环境下编程，系统给提供了一组宏定义，可以对我们的fd_set进行赋值等操作。</p>
<p>Demo:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;usage: select01 &lt;IPaddress&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> socket_fd = tcp_client(argv[<span class="number">1</span>], SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> recv_line[MAXLINE], send_line[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    fd_set readmask;</span><br><span class="line">    fd_set allreads;</span><br><span class="line">    FD_ZERO(&amp;allreads);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;allreads);</span><br><span class="line">    FD_SET(socket_fd, &amp;allreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        readmask = allreads;</span><br><span class="line">        <span class="keyword">int</span> rc = select(socket_fd + <span class="number">1</span>, &amp;readmask, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">&quot;select failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(socket_fd, &amp;readmask)) &#123;</span><br><span class="line">            n = read(socket_fd, recv_line, MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="number">1</span>, errno, <span class="string">&quot;read error&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;server terminated \n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            recv_line[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fputs</span>(recv_line, <span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readmask)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(send_line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="built_in">strlen</span>(send_line);</span><br><span class="line">                <span class="keyword">if</span> (send_line[i - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                    send_line[i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;now sending %s\n&quot;</span>, send_line);</span><br><span class="line">                <span class="keyword">size_t</span> rt = write(socket_fd, send_line, <span class="built_in">strlen</span>(send_line));</span><br><span class="line">                <span class="keyword">if</span> (rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">&quot;write failed &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;send bytes: %zu \n&quot;</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><blockquote>
<p>poll其实本质和select一样没有太大的区别，主要有几点改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">short</span> events;</span><br><span class="line">	<span class="keyword">short</span> revents;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds. <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Events可以表示多个不同的事件，具体的实现可以通过二进制掩码位操作来完成，例如<code>POLLIN</code>和<code>POLLOUT</code>表示可读可写事件。</p>
</li>
<li><p>与select不同的在于，poll每次检测之后的结果不会修改元凯的传入的值，而是将结果保留在revents字段中，这样就不用每次检测完成之后都要重置待检测的描述字和感兴趣的事件。revents可以理解<code>return events</code>。</p>
</li>
<li><p>如果对某个pollfd结构进行事件检测，可以将对应的pollfd结构的fd成员设置成一个负值，poll函数将会忽略该事件。</p>
</li>
<li><p>突破了select(1024)最大文件描述符的限制，原因是它是基于链表来存储</p>
</li>
</ul>
<p> <strong>同样存在缺点：</strong></p>
<p> 1、依旧是大量的fd数组在用户空间和内核空间之间进行拷贝。</p>
<p> 2、poll是水平触发，如果fd就绪被报告之后没有对其进行处理，下次poll韩式会再次报告该事件。</p>
</blockquote>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><p>epoll_create 函数是一个系统调用函数，函数将会在内核空间开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。</p>
</li>
<li><p>epoll_ctl是epoll事件的注册函数，epoll与select不同，select函数是调用时指定的需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间内，此函数是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。<br>  参数1：epfd，epoll结构的进程fd编号，函数将依靠该编号找到对应的epoll结构。<br>  参数2：op，表示当前的请求的类型，由三个定义：</p>
<pre><code>           EPOLL_CTL_ADD:注册新的fd到epoll中。
           EPOLL_CTL_MOD:修改已经注册的fd的监听事件。
           EPOLL_CTL_DEL:从epfd中删除一个fd。
</code></pre>
<p>  参数3：fd,需要监听的文件描述符，一般指的是sockfd。<br>  参数4：event，告诉内核该fd资源感兴趣的事件。</p>
</li>
<li><p>epoll_wait函数，等待事件的发生，类似于select()函数调用。根据参数timeout，决定是否处于阻塞模式。<br>  参数1：epfd，指定一个感兴趣事件列表。<br>  参数2：*events，是一个指针，必须指向一个epoll_event结构数组，当函数返回的时候，内核会将就绪状态的的数据拷贝到该数组中。<br>  参数3：maxevents，标明参数2epoll_event结构数组最多能接收的数据量，即本次操作做多能获取多少就绪数据。<br>  参数4: timeout，单位为毫秒。</p>
<pre><code> 0：表示立即返回。
 -1：阻塞调用，直到有用户感兴趣事件就绪为止。
</code></pre>
</li>
</ul>
<p>(1) epoll_create 函数是一个系统调用函数，函数将会在内核空间开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。</p>
<p>(2) epoll_ctl是epoll事件的注册函数，epoll与select不同，select函数是调用时指定的需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间内，此函数是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。<br>  参数1：epfd，epoll结构的进程fd编号，函数将依靠该编号找到对应的epoll结构。<br>  参数2：op，表示当前的请求的类型，由三个定义：<br>               EPOLL_CTL_ADD:注册新的fd到epoll中。<br>               EPOLL_CTL_MOD:修改已经注册的fd的监听事件。<br>               EPOLL_CTL_DEL:从epfd中删除一个fd。<br>  参数3：fd,需要监听的文件描述符，一般指的是sockfd。<br>  参数4：event，告诉内核该fd资源感兴趣的事件。</p>
<p>(3)epoll_wait函数，等待事件的发生，类似于select()函数调用。根据参数timeout，决定是否处于阻塞模式。<br>  参数1：epfd，指定一个感兴趣事件列表。<br>  参数2：*events，是一个指针，必须指向一个epoll_event结构数组，当函数返回的时候，内核会将就绪状态的的数据拷贝到该数组中。<br>  参数3：maxevents，标明参数2epoll_event结构数组最多能接收的数据量，即本次操作做多能获取多少就绪数据。<br>  参数4: timeout，单位为毫秒。<br>         0 表示立即返回。</p>
<p>​        -1 阻塞调用，直到有用户感兴趣事件就绪为止。</p>
<p>​        &gt;0 阻塞调用，阻塞指定的时间内如果有时间就绪则是提前返回，否则就等待指定的事件后返回。<br>  返回值（return value）：本次就绪的fd的个数。</p>
<p>工作模式：<br>       epoll对文件描述符的操作有两种模式：LT(水平触发)和ET(边缘触发)。LT是默认模式，两者的区别如下：<br>       LT(level 水平触发)：事件就绪之后，用户可以选择处理或者不处理，如果用户本次未进行处理，那么下次调用epoll_wait时候仍然会将未出的事件打包给你。<br>       ET(edge 边缘触发)： 事件就绪之后，用户必须处理，因为内核不给给你兜底，内核把就绪的事件打包给用户态之后，就会把对应的就绪事件清理掉，不会再次通知用户。<br>       ET模式在很大的程度上减少了epoll事件被重复触发的次数，因此被认为效率比LT模式高，也是epoll重要的杀手锏。</p>
<p><strong>epoll优点：</strong></p>
<p>1、没有最大文件描述符限制</p>
<p>2、使用mmap文件映射内存加速与内核空间的消息传递，不再是大量的fd从用户空间拷贝到内核空间，大大减少了拷贝的开销。</p>
<p>3、效率提升，不再使用轮询</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、<a href="https://blog.csdn.net/qq_35976351/article/details/85228002">https://blog.csdn.net/qq_35976351/article/details/85228002</a></p>
<p>2、<a href="https://time.geekbang.org/column/article/138948">https://time.geekbang.org/column/article/138948</a></p>
]]></content>
      <categories>
        <category>Unix环境编程</category>
      </categories>
  </entry>
  <entry>
    <title>信号signal</title>
    <url>/2021/01/03/%E4%BF%A1%E5%8F%B7signal/</url>
    <content><![CDATA[<h1 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h1><blockquote>
<p>信号：</p>
<p>信号是一种软中断，信号提供了一种处理异步事件的方法。比如终端运行着一个程序，我们在设备输入一个ctrl+c中断停止的按键，那么我们实际上通过触发一个信号（）停止了一个程序。</p>
<p>信号的处理：</p>
<p>（1）可以直接将其忽略掉。大多数信号可以直接忽略掉但有两种信号却决不能被忽略，它们是SIGKILL和SIGSTOP信号。</p>
<p>（2）捕捉信号，注册信号处理函数。</p>
<p>（3）执行系统的默认动作。</p>
<p>进程创建：</p>
<p>当一个进程调用fork函数的时候，其子进程会直接继承父进程的信号处理方式，因为子进程在开始复制了父进程的春初对象，所以信号捕捉函数的地址在子进程中是有意义的。</p>
</blockquote>
]]></content>
      <categories>
        <category>Unix环境编程</category>
      </categories>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2020/12/20/docker/</url>
    <content><![CDATA[<p>Docker 本质上就是一个虚拟机。</p>
<p><img src="/2020/12/20/docker/image.png" alt="image-20201220085110478"></p>
<p>在docker中有几个基本的概念。</p>
<p>1、镜像：类似于平时使用的iso或者image镜像文件。</p>
<p>2、容器：容器其实就会类似于虚拟机</p>
<p>3、tar文件：类似于vmdk文件，可以直接打个包在别的地方直接run运行。</p>
<p>4、docker file。docker 的一些配置</p>
<p>5、仓库：存放有很多已经打包好的镜像，MySQL镜像、ngnix镜像等。</p>
<p>常用的操作命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、直接从远程仓库下载mysql镜像</span><br><span class="line">docker search mysql 查找mysql镜像</span><br><span class="line">docker pull mysql   下载mysql镜像</span><br><span class="line">等价于命令docker pull mysql:latest,不指定版本会直接默认下载最新的版本镜像。</span><br><span class="line"></span><br><span class="line">2、查看本地的镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">3、运行容器</span><br><span class="line">docker run -d 3307:3306 mysql</span><br><span class="line">-d 指定后台运行不阻塞当前shell窗口</span><br><span class="line">-p 指定内外部端口映射 外部:内部</span><br><span class="line"></span><br><span class="line">4、查看正在运行的容器，查看活跃的容器。</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">5、进入容器</span><br><span class="line">docker exec -it id bash</span><br><span class="line"></span><br><span class="line">6、启动停止容器</span><br><span class="line">docker stop &lt;容器ID&gt;</span><br><span class="line">docker restart &lt;容器ID&gt;</span><br><span class="line"></span><br><span class="line">7、删除docker实例</span><br><span class="line">docker rm -f 实例ID</span><br><span class="line"></span><br><span class="line">8、查询mysql镜像</span><br><span class="line">docker search mysql</span><br><span class="line"></span><br><span class="line">9、保存容器镜像</span><br><span class="line">docker commit 实例ID 新的名字</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/20/docker/image1.png" alt="image-20201220090133527"></p>
]]></content>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2020/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="三大总线"><a href="#三大总线" class="headerlink" title="三大总线"></a>三大总线</h2><p>1、地址总线</p>
<p>2、控制总线</p>
<p>3、数据总线</p>
]]></content>
  </entry>
  <entry>
    <title>人为什么活着</title>
    <url>/2020/10/13/%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="你喜欢的人在努力，你却在想怎么说我爱你"><a href="#你喜欢的人在努力，你却在想怎么说我爱你" class="headerlink" title="你喜欢的人在努力，你却在想怎么说我爱你"></a>你喜欢的人在努力，你却在想怎么说我爱你</h1>]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>标签测试文章</title>
    <url>/2020/10/06/%E7%BC%96%E5%86%99Makefile/</url>
    <content><![CDATA[<h1 id="编写Makefile"><a href="#编写Makefile" class="headerlink" title="编写Makefile"></a>编写Makefile</h1><hr>
<p>&ensp;&ensp;&ensp;&ensp;Makefile编写的好可以在工程项目编译链接的过程中省去很多麻烦，平时在练习的过程中也是能方便高效的学习。</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<h2 id="一、Makefile相关知识点"><a href="#一、Makefile相关知识点" class="headerlink" title="一、Makefile相关知识点"></a>一、Makefile相关知识点</h2><p>&ensp;&ensp;&ensp;&ensp;需要掌握的一些Makefile相关的基础知识。</p>
<h3 id="1-忽略出错的命令。"><a href="#1-忽略出错的命令。" class="headerlink" title="1. 忽略出错的命令。"></a>1. 忽略出错的命令。</h3><p>&ensp;&ensp;&ensp;&ensp;如果不希望某条命令因为出错了而导致整个make执行被终止，可以在命令前面加上“-”，表示不管该命令出不出错，后面的命令都将继续执行下去。如：<br>&ensp;&ensp;&ensp;&ensp;mkdir lpyuan<br>&ensp;&ensp;&ensp;&ensp;如果不加“-”并且dir已经存在，则这条命令就会出错，并将导致整个make执行被终止。要想不被终止，则需要在前加上’-‘符号。<br>&ensp;&ensp;&ensp;&ensp;-mkdir dir</p>
<h3 id="2-显示命令。"><a href="#2-显示命令。" class="headerlink" title="2. 显示命令。"></a>2. 显示命令。</h3><p>&ensp;&ensp;&ensp;&ensp;一般默认make会把命令原样显示出来后再去执行命令，如果我们不需要原样显示命令，则可以在命令前面加一个“@”， 如<br>&ensp;&ensp;&ensp;&ensp;@m -rf lpyuan<br>&ensp;&ensp;&ensp;&ensp;则是不会输出命令。</p>
<h3 id="3-符号。"><a href="#3-符号。" class="headerlink" title="3. 符号。"></a>3. 符号。</h3><p>&ensp;&ensp;&ensp;&ensp;$@  表示目标文件<br>&ensp;&ensp;&ensp;&ensp;$^  表示所有的依赖文件<br>&ensp;&ensp;&ensp;&ensp;$&lt;  表示第一个依赖文件<br>&ensp;&ensp;&ensp;&ensp;$?  表示比目标还要新的依赖文件列表</p>
<p>如一个目录下有如下文件：<br>&ensp;&ensp;&ensp;&ensp;hello.c&ensp;&ensp;hi.c&ensp;&ensp;main.c&ensp;&ensp;Makefile<br>按照 Makefile 规则规规矩矩的写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main: main.o hello.o hi.o</span></span><br><span class="line">        gcc -o main main.o hello.o hi.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">        cc -c main.c</span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">        cc -c hello.c</span><br><span class="line"><span class="section">hi.o: hi.c</span></span><br><span class="line">        cc -c hi.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o</span><br><span class="line">        rm main</span><br><span class="line">        </span><br><span class="line">改为用上述符号进行替代：</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o hello.o hi.o</span></span><br><span class="line">        gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">hi.o: hi.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o</span><br><span class="line">        rm main</span><br></pre></td></tr></table></figure>
<h3 id="4-Makefile中的常用函数。"><a href="#4-Makefile中的常用函数。" class="headerlink" title="4. Makefile中的常用函数。"></a>4. Makefile中的常用函数。</h3><h4 id="4-1-函数名称-：反过滤函数—filter-out。"><a href="#4-1-函数名称-：反过滤函数—filter-out。" class="headerlink" title="4.1 函数名称 ：反过滤函数—filter-out。"></a>4.1 函数名称 ：反过滤函数—filter-out。</h4><p>格式：$(filter-out PATTERN…,TEXT)<br>函数功能 ：和“filter”函数实现的功能相反。过滤掉字串“TEXT”中所有符合“PATTERN”的单词，保留所有不符合的单词。可以多个模式。存在多模式时，模式表达式之间使用空格分割。<br>返回值 ：空格分割的“TEXT”字串中所有不符合模式“PATTERN”的字串。<br>函数说明： “filter-out”函数也可以用来去除一个变量中的某些字符串（实现和“filter”函数相反）。<br>下面有个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects&#x3D;main1.o foo.o main2.o bar.o </span><br><span class="line">mains&#x3D;main1.o main2.o</span><br><span class="line">$(filter-out$(mains),$(objects))</span><br><span class="line">实现了去除变量&quot;objects&quot;中&quot;mains&quot;定义的字串（文件名）功能。它的返回值为&quot;foo.o bar.o&quot;。</span><br></pre></td></tr></table></figure>
<h2 id="二、Makefile通用模板"><a href="#二、Makefile通用模板" class="headerlink" title="二、Makefile通用模板"></a>二、Makefile通用模板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TARGET&#x3D;server</span><br><span class="line">CC&#x3D;g++</span><br><span class="line">CFLAG&#x3D;-c -g -static</span><br><span class="line">#所有的.c文件</span><br><span class="line">SRCS:&#x3D;$(wildcard ..&#x2F;*.c)</span><br><span class="line">FILTERS&#x3D;..&#x2F;hello.c</span><br><span class="line">#从SRCS中除了hello.c文件 filter函数可以选择满足条件的</span><br><span class="line">SRCS:&#x3D;$(filter-out $(FILTERS), $(SRCS))</span><br><span class="line">OBJS:&#x3D;$(patsubst %.c, %.o, $(SRCS))</span><br><span class="line">CURRENT_PATH&#x3D;$(PWD)</span><br><span class="line">CPPFLAGS&#x3D; -I..&#x2F;include -I..&#x2F;util</span><br><span class="line">LIBS_PATH&#x3D;-L..&#x2F;lib64</span><br><span class="line">LIBS&#x3D;-lmylib</span><br><span class="line"></span><br><span class="line">#判断是哪个系统32bit编译还是在64bit编译。</span><br><span class="line">ARCH:&#x3D;$(shell uname -m)</span><br><span class="line">ifeq ($(ARCH), x86_64)</span><br><span class="line">VERSION:&#x3D;X86_64</span><br><span class="line">else</span><br><span class="line">VERSION:&#x3D;i686</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">        $(CC) $(DEBUG) $(SRCS) $(LIBS_PATH) $(LIBS) $(CPPFLAGS) -o $(TARGET)</span><br><span class="line"></span><br><span class="line">$(OBJS):%.o:%.c</span><br><span class="line">        $(CC) $(CFLAG) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        rm -rf *~ *.bak $(TARGET)</span><br><span class="line"></span><br><span class="line">【顶层Makefile编写】</span><br><span class="line">all: all_client all_server</span><br><span class="line">    rm -rf *~ *.bak</span><br><span class="line">all_client:</span><br><span class="line">    $(MAKE) -C client</span><br><span class="line">all_server:</span><br><span class="line">    $(MAKE) -C server</span><br><span class="line"></span><br><span class="line">clean: clean_client clean_server</span><br><span class="line">    rm -rf *~ *.bak</span><br><span class="line">clean_client:</span><br><span class="line">    $(MAKE) -C client clean</span><br><span class="line">clean_server:</span><br><span class="line">    $(MAKE) -C server clean</span><br></pre></td></tr></table></figure>
<hr>
<p>感谢您花费时间阅读这篇文章，书中有错误的地方或者有什么建议都可以留言，或者通过邮件祝您在这里记录、阅读、分享愉快！</p>
<p>作&ensp;者:&ensp;lpyuan<br>Email:&ensp;<a href="mailto:&#x6c;&#x70;&#121;&#x75;&#97;&#x6e;&#x32;&#49;&#64;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#109;">&#x6c;&#x70;&#121;&#x75;&#97;&#x6e;&#x32;&#49;&#64;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#x6f;&#x6b;&#x2e;&#x63;&#111;&#109;</a><br>2020年02月28日 02:52:00   </p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯面试</title>
    <url>/2020/11/16/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>1、100万数据个是topK。</p>
<p>2、32位无符号整形个数的QQ号记录QQ号的状态 上线和下线，计算使用多少内存。</p>
<p>3、printf(“%d “, 1, 2, 3);  printf(“%s”)；</p>
<p>4、HTTP 和 HTTPS的区别。1、对称加密和非对称加密。2、效率问题的瓶颈。</p>
<p>5、阻塞问题</p>
<p>1、对端接收处理不过来 。流量控制。</p>
<p>2、网络阻塞。拥塞控制。</p>
<p>3、项目问题</p>
]]></content>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/2021/01/04/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<blockquote>
<p><strong>原子操作</strong>，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。</p>
<p>线程同步的主要方式–线程锁 线程同步最常用的方法是使用<strong>锁</strong>(Lock)。锁是一种非强制机制，每一个线程访问数据或资源之前，首先试图获取(Acquireuytreewq)锁,并在访问结束之后释放(release)。在锁已经被占用时获取锁，线程会等待，直到该锁被释放。</p>
<p><strong>互斥锁</strong> 是在很多平台上都比较常用的一种锁。它属于sleep-waiting类型的锁。即当锁处于占用状态时，其他线程会挂起，当锁被释放时，所有等待的线程都将被唤醒，再次对锁进行竞争。在挂起与释放过程中，涉及用户态与内核态之间的context切换，而这种切换是比较消耗性能的。</p>
<p><strong>自旋锁</strong> 与互斥锁有点类似，只是自旋锁被某线程占用时，其他线程不会进入睡眠(挂起)状态，而是一直运行（自旋/空转）直到锁被释放。由于不涉及用户态与内核态之间的切换，它的效率远远高于互斥锁。</p>
<p>**信号量(Semaphore)**，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。</p>
<p>信号量可以分为几类：</p>
<ul>
<li>二进制信号量(binary semaphore) / 二元信号量 ：只允许信号量取0或1值，，只有两种状态：占用与非占用，其同时只能被一个线程获取。</li>
<li>整型信号量（integer semaphore)：信号量取值是整数，它可以被多个线程同时获得，直到信号量的值变为0。</li>
<li>记录型信号量（record semaphore)：每个信号量s除一个整数值value（计数）外，还有一个等待队列List，其中是阻塞在该信号量的各个线程的标识。当信号量被释放一个，值被加一后，系统自动从等待队列中唤醒一个等待中的线程，让其获得信号量，同时信号量再减一。</li>
</ul>
<p>信号量通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将该整数减一。如果计数器大于0，则访问被允许，计数器减1；如果为0，则访问被禁止，所有试图通过它的线程都将处于等待状态。</p>
<p><strong>条件变量</strong> （Condition Variable） 作为一种同步手段类似于栅栏，允许线程以一种无竞争的方式等待某个条件的发生。当该条件没有发生时，线程会一直处于休眠状态。当被其它线程通知条件已经发生时，线程才会被唤醒从而继续向下执行。条件变量是比较底层的同步原语，直接使用的情况不多，往往用于实现高层之间的线程同步。使用条件变量的一个经典的例子就是线程池(Thread Pool)了。</p>
</blockquote>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><blockquote>
<p>共享内存允许两个或者多个进程共享一个给定的存储区，因为数据不需要再客户即和服务器之间复制，所以共享内存是最快的一种 I IPC。使用共享内存唯一的诀窍就是多个进程之间对一给定的存储区之间数据的同步存取问题。通常，信号量被用来实现对共享存储存取的同步。（记录锁也可以用于这种场合）。</p>
<p>对于操作系统而言，在并行程序设计中难免会遇到数据同步和共享的问题，本文针对这个问题，以windows系统为例回顾一下资源同步的相关问题。</p>
<p>要点如下：</p>
<p>1.同步和数据共享数据征用</p>
<p>2.同步原语 1.互斥和临界区 2.自旋锁 3.信号量 4.读写锁 5.屏障 6.原子操作与无锁代码</p>
</blockquote>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>1、<a href="https://juejin.cn/post/6844903543527178248">https://juejin.cn/post/6844903543527178248</a></p>
]]></content>
      <categories>
        <category>Unix环境编程</category>
      </categories>
  </entry>
  <entry>
    <title>手撕代码</title>
    <url>/2020/12/27/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="面试常见的手撕代码题型"><a href="#面试常见的手撕代码题型" class="headerlink" title="面试常见的手撕代码题型"></a>面试常见的手撕代码题型</h1><p>所有代码都已经跑过</p>
<h2 id="经典排序"><a href="#经典排序" class="headerlink" title="经典排序"></a>经典排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 交换两个数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 冒牌排序算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == arr)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;len-i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])</span><br><span class="line">        swap(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  BubbleSort(arr);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p>0 1 5 7 7 7 8 8 9</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* temp存放的是基数 */</span></span><br><span class="line">  temp = arr[left];</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">    <span class="comment">/* 顺序很重要，要从右边开始找 */</span></span><br><span class="line">    <span class="keyword">while</span>(arr[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">      j--;</span><br><span class="line">    <span class="comment">/* 再从左开始找 */</span></span><br><span class="line">    <span class="keyword">while</span>(arr[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">      swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">  </span><br><span class="line">  quickSort(left, i<span class="number">-1</span>);</span><br><span class="line">  quickSort(i+<span class="number">1</span>, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找也叫做折半查找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hight = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid, midVal;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= hight)&#123;</span><br><span class="line">        mid = (low+hight)/<span class="number">2</span>;</span><br><span class="line">        midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(midVal &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midVal &gt; key)</span><br><span class="line">            hight = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">-32</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">98</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the data.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);</span><br><span class="line">    <span class="keyword">int</span> ret = binarySearch(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the key %d is exits.\n&quot;</span>, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the key %d is not exits.\n&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义链表结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">listNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 反转链表 */</span></span><br><span class="line"><span class="function">listNode *<span class="title">reverseList</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == head || <span class="literal">NULL</span> == head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  listNode *cur = head;</span><br><span class="line">  listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">  listNode *next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">/* 存放下一个节点 */</span></span><br><span class="line">    next = cur-&gt;next;</span><br><span class="line">    <span class="comment">/* 翻转头结点的下一个节点 */</span></span><br><span class="line">    cur-&gt;next = prev;</span><br><span class="line">    <span class="comment">/* 移动上一个节点 */</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    <span class="comment">/* 更新当前节点 */</span></span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> prev；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==i%<span class="number">16</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断链表是否有环 */</span></span><br><span class="line"><span class="function">linkNode *<span class="title">isCircle</span><span class="params">(linkNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    linkNode *slow = head-&gt;next;               <span class="comment">/* 慢指针 */</span></span><br><span class="line">    linkNode *fast = head-&gt;next-&gt;next;         <span class="comment">/* 快指针 */</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">/* 无环 */</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> slow;    <span class="comment">/* 有环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="实现memcpy函数"><a href="#实现memcpy函数" class="headerlink" title="实现memcpy函数"></a>实现memcpy函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 不考虑内存重叠的情况 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myMemcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == dest||<span class="literal">NULL</span> == src)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> *d = (<span class="keyword">char</span> *)dest;</span><br><span class="line">  <span class="keyword">char</span> *s = (<span class="keyword">char</span> *)src;</span><br><span class="line">  <span class="keyword">while</span>(n--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化版本按照CPU位宽度进行拷贝优化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  *<span class="title">myMemcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nchucks = num/<span class="keyword">sizeof</span>(dest);  <span class="comment">/* 按照CPU的位宽进行拷贝 */</span></span><br><span class="line">  <span class="keyword">int</span> slice = num%/<span class="keyword">sizeof</span>(dest);   <span class="comment">/* 剩余的字节数按照一个一个字节进行拷贝 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *s = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)src;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)dest;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">while</span>(nchucks--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">while</span>(slice--)</span><br><span class="line">    *((<span class="keyword">char</span>*)d++) = *((<span class="keyword">char</span>*)s++);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 考虑内存重叠的情况 */</span></span><br></pre></td></tr></table></figure>


<h3 id="实现strstr函数"><a href="#实现strstr函数" class="headerlink" title="实现strstr函数"></a>实现strstr函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myStrstr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现strlen函数"><a href="#实现strlen函数" class="headerlink" title="实现strlen函数"></a>实现strlen函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStrlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(arr);</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">&#x27;\0&#x27;</span> != *arr++)</span><br><span class="line">    count++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现strcpy函数"><a href="#实现strcpy函数" class="headerlink" title="实现strcpy函数"></a>实现strcpy函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">myStrcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(dest);</span><br><span class="line">  assert(src);</span><br><span class="line">  <span class="keyword">char</span> *d = dest;</span><br><span class="line">  <span class="keyword">char</span> *s = src;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">&#x27;\0&#x27;</span> != *s)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、<a href="https://blog.csdn.net/weixin_43496874/article/details/100868367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control">https://blog.csdn.net/weixin_43496874/article/details/100868367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control</a></p>
<p>2、<a href="http://c.biancheng.net/cpp/html/2744.html">http://c.biancheng.net/cpp/html/2744.html</a></p>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
  </entry>
  <entry>
    <title>海量数据处理问题</title>
    <url>/2021/01/07/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-海量数据问题"><a href="#1-海量数据问题" class="headerlink" title="1 海量数据问题"></a>1 海量数据问题</h2><h3 id="1-1-海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#1-1-海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="1.1 海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>1.1 海量日志数据，提取出某日访问百度次数最多的那个IP。</h3><p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p>
<p>算法思想：分而治之+哈希</p>
<p>1、IP地址最多有2^32=4G种取值情况，所以不能一次性直接都完全加载到内存中。</p>
<p>2、考虑分而治之的思想，将IP地址进行hash(IP)%1024，把海量的数据分别存储到1024个文件中，这样，每个文件最有就含有4MB个IP地址。</p>
<p>3、对于每一个小文件，可以进行构造一个key value的hash map，将IP作为key值，出现的次数作为value值，同时记录下当前出现次数最多的那个IP地址。</p>
<p>4、可以得到1024个文件📃中出现次数最多的IP，再根据常规的排序算法得到总体上的出现次数最多的IP。</p>
<h3 id="1-2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节"><a href="#1-2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节" class="headerlink" title="1.2 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节"></a>1.2 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节</h3><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>算法思想：经典的topK问题。</p>
<p>1、先对这批海量数据进行预处理，在O(n)的时间之内用hash表完成统计。</p>
<p>2、借助堆这个数据结构，找出topk，时间复杂度为nlogK。借助堆这个数据结构，我们可以在log量级的时间内查找和调整移动。我们可以维护一个大顶堆，然后遍历这300万左右的数据，分别和根元素进行比对，最后得出前十个热门的查询串。</p>
<h3 id="1-3-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词"><a href="#1-3-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词" class="headerlink" title="1.3 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词"></a>1.3 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</h3><p>算法思想：分而治之+hash</p>
<p>1、顺序读取文件，对于读取的每一个值，可以使用hash(x)%5000，将读取的词存储到5000个文件中，每个文件大概200k，如果还是有文件大于1m，可以按照这个方法继续往下分，直到可以直接放入内存中为止。</p>
<p>2、对于每一个小文件，统计每个文件节点中出现的词以及相应的一个频率（tries树🌲或者hashMap都可以）。取出出现频率最大的一百个词（可以采用含有100个节点的最小堆），这样又可以得到5000个文件。最后一步，可以将这5000个文件进行归并过程了（类似于归并排序）。</p>
<h3 id="1-4-在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。"><a href="#1-4-在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。" class="headerlink" title="1.4 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。"></a>1.4 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</h3><p>方案1：可以采用2-bitmap进行，共需要内存</p>
<h3 id="1-5-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#1-5-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="1.5 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>1.5 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3><h3 id="1-6-腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#1-6-腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="1.6 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>1.6 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h3><p>使用bitmap，或者布隆过滤器。</p>
<h3 id="1-7-10亿个域名如何判断，新来一个域名，如何判断在还是不在"><a href="#1-7-10亿个域名如何判断，新来一个域名，如何判断在还是不在" class="headerlink" title="1.7 10亿个域名如何判断，新来一个域名，如何判断在还是不在"></a>1.7 10亿个域名如何判断，新来一个域名，如何判断在还是不在</h3><p>可以使用布隆过滤器，判断不在就一定不在，判断在的话可能不在。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>结构体对齐</title>
    <url>/2021/01/06/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>结构体对齐一直是一个老生常谈的问题，我面试过就被问过几次，但是每一次都复习准备好好的，但是一到面试时候，总能被面试官问倒（卑微~）其实主要的原因就是自己没有准确的深刻的理解结构体对齐这个知识点，没有对其进行一个总结。</p>
</blockquote>
<h2 id="为什么需要结构体对齐"><a href="#为什么需要结构体对齐" class="headerlink" title="为什么需要结构体对齐"></a>为什么需要结构体对齐</h2><p>结构体需要对其的原因主要就是对CPU对内存访问效率优化的一个问题。假设是intel 32的CPU， 每个总线周期都是要从偶地址读取32位的内存数据。</p>
<p>假设我们的CPU和总线都是64位的，每次可以从内存中获取8个字节（Byte）64位（bit）的数据，这8个字节就是对齐的，假设就是0<del>7，8</del>15类似这样，你不能从中间3<del>10这样取值。如果需要取值3</del>10之间的数据，就需要取两次，分别是0<del>7，再取8</del>15。所以CPU的取值效率就下降了。</p>
<h2 id="对齐的几个基本的原则"><a href="#对齐的几个基本的原则" class="headerlink" title="对齐的几个基本的原则"></a>对齐的几个基本的原则</h2><p>1、结构体变量的起始地址能够被其最宽的成员大小整除。</p>
<p>2、结构体每个成员相对于起始地址的偏移能够被自身大小整除，如果不能则在前一个成员后面补充字节。</p>
<p>3、结构体总的大小能够被最宽的成员大小整除，如果不能则是在后面进行一个补齐。</p>
<p>结构体其实也是可以指定编译器对齐大小的，例如以下的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>  b;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br></pre></td></tr></table></figure>
<p>sizeof(a)的大小为5。</p>
<h2 id="几种变形情况"><a href="#几种变形情况" class="headerlink" title="几种变形情况"></a>几种变形情况</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>  b;</span><br><span class="line">	<span class="keyword">short</span> c;</span><br><span class="line">&#125;A1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量a，自身按1字节对齐，</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.zhihu.com/question/27862634">https://www.zhihu.com/question/27862634</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1055149?from=information.detail.linux%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90">https://cloud.tencent.com/developer/article/1055149?from=information.detail.linux%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90</a></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2020/03/04/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<h1 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h1><p>&ensp;&ensp;&ensp;&ensp;链表是一组数据项的集合，其中每一个数据项都是一个节点的一部分，每一个节点都包含有指向下一个节点的链接。</p>
<h1 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h1><p>（1）<strong>逻辑结构</strong>。数组需要实现定义固定长度（元素个数），不能适应动态的增加或者删除数据元素。<br>（2）<strong>内存结构</strong>。（静态）数组从占空间分配内存，快捷方便，但是自由度小。链表从堆中进行分配，自由度大。<br>（3）<strong>存储结构</strong>。数组在内存中是顺序存储，而链表是随机存储。数组的访问效率很高，但是插入和删除效率低，链表相反。<br>（4）数组会存在越界的问题，但是链表不会。</p>
<h1 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h1><h2 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h2><p>&ensp;&ensp;&ensp;&ensp;缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU缓存、数据库缓存、浏览器缓存等等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：<strong>先进先出策略</strong> FIFO（First In，First Out）、<strong>最少使用策略</strong> LFU（Least Frequently Used）、<strong>最近最少使用策略</strong> LRU（Least Recently Used）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ture 1</span><br><span class="line">#define false 0</span><br><span class="line"></span><br><span class="line">typedef int Data_type;</span><br><span class="line">typedef struct _Node&#123;</span><br><span class="line">	Data_type data;</span><br><span class="line">	struct _Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">&#x2F;* 将数据插入到头部 *&#x2F;</span><br><span class="line">void intsert_elem_to_begin(Data_type data);</span><br><span class="line"></span><br><span class="line">&#x2F;* 查找元素，存在则是返回1，不存在返回0 *&#x2F;</span><br><span class="line">int find_elem(Data_type data);</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除链表尾部结点 *&#x2F;</span><br><span class="line">void dalete_tail_elem();</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除指定元素结点 *&#x2F;</span><br><span class="line">int delete_elem(Data_type data);</span><br><span class="line"></span><br><span class="line">&#x2F;* 判断链表是否满 *&#x2F;</span><br><span class="line">int is_full();</span><br><span class="line"></span><br><span class="line">&#x2F;* 判断链表是否为空 *&#x2F;</span><br><span class="line">int is_empty();</span><br><span class="line"></span><br><span class="line">&#x2F;* 打印所有数据 *&#x2F;</span><br><span class="line">void show_all();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>感谢您花费时间阅读这篇文章，书中有错误的地方或者有什么建议都可以留言，或者通过邮件祝您在这里记录、阅读、分享愉快！</p>
<p>作&ensp;者:&ensp;lpyuan<br>Email:&ensp;<a href="mailto:&#x6c;&#x70;&#121;&#117;&#x61;&#x6e;&#x32;&#x31;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#111;&#x6b;&#46;&#99;&#111;&#109;">&#x6c;&#x70;&#121;&#117;&#x61;&#x6e;&#x32;&#x31;&#64;&#x6f;&#x75;&#116;&#108;&#111;&#111;&#x6b;&#46;&#99;&#111;&#109;</a><br>2020年02月28日 02:52:00   </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>面试笔试</title>
    <url>/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="大端小端网络字节序"><a href="#大端小端网络字节序" class="headerlink" title="大端小端网络字节序"></a>大端小端网络字节序</h2><p>&ensp;&ensp;&ensp;&ensp;”大端”，”小端”指的是表示多字节的值哪一端存储在该值的起始地址处；多字节小端存储起始地址处称为小端字节序，多字节的大端存储在起始地址处称为大端字节序。<br>&ensp;&ensp;&ensp;&ensp;通俗的说就是。</p>
<p>&ensp;&ensp;&ensp;&ensp;常用的X86架构就是采用的小端存储，最高有效位在最高位地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;大端字节序：最高有效位存于最低的内存地址，最低的有效位存于最高的内存地址。<br>&ensp;&ensp;&ensp;&ensp;小端字节序：最高有效位存于最高的内存地址，最低的有效位存于最低的内存地址。<br><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image1.jpg" alt="图来源于网络"><br>&ensp;&ensp;&ensp;&ensp;网络字节序，网络上传输的数据都是字节流。**UDP/TCP/IP协议规定:**把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节。而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,<strong>多字节数值在发送之前,在内存中因该是以大端法存放的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">union 联合体成员存放的顺序都是从低地址开始存放，并且是所有的成员共享同一个内存空间，</span></span><br><span class="line"><span class="comment">可以利用这个特性进行一个大小端的判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义联合体结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">testUnion</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;testUnion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断大小端 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isBigEndStorage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testUnion a;</span><br><span class="line">    a.a = <span class="number">0x01</span>;</span><br><span class="line">    <span class="keyword">return</span> a.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == isBigEndStorage())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端存储&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><p>&ensp;&ensp;&ensp;&ensp;为什么建立连接需要三次握手？TCP的两次握手是最基本的，第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。<br>&ensp;&ensp;&ensp;&ensp;客户端只有确定了自己能与服务端连接上才能开始发数据。所以两次握手肯定是最基本的。<br>&ensp;&ensp;&ensp;&ensp;到了这，有人肯定又有疑问，两次握手不就可以了吗，为什么需要第三次握手。其实，第三次握手主要的原因是防止已经失效的连接请求报文由于某种原因突然又回到服务端，从而就会产生错误。比如，一个请求的数据包，因为某些原因滞留在网络中很久，一直到了连接释放的时候才到达服务端，这时候，服务端以为是客户端的第一次连接回应了客户端从而建立了连接，实际上是不必要的连接客户端并没有任何数据要发送，当存在大量的这种情况下，会造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。<br><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image2.jpg" alt="图来源于网络"></p>
<h2 id="TCP与UDP的概念"><a href="#TCP与UDP的概念" class="headerlink" title="TCP与UDP的概念"></a>TCP与UDP的概念</h2><p>&ensp;&ensp;&ensp;&ensp;TCP:一种面向连接的，可靠的，基于字节流的通信协议。<br>&ensp;&ensp;&ensp;&ensp;UDP:提供无连接的通信，不可靠的，基于数据报的通信协议。<br><strong>两者的主要区别是</strong>：<br>&ensp;&ensp;&ensp;&ensp;（1）TCP是面向连接的传输控制协议，而UDP是提供无连接的数据报服务。<br>&ensp;&ensp;&ensp;&ensp;（2）TCP具有高可靠性，能确保数据的完整性和正确性。<br>&ensp;&ensp;&ensp;&ensp;（3）TCP需要的系统资源比较多，而UDP需要的就相对少一些。<br>&ensp;&ensp;&ensp;&ensp;（4）UDP实时性比较高，低延迟，但是TCP的工作效率相对高一些。</p>
<h2 id="UDP调用connect函数作用"><a href="#UDP调用connect函数作用" class="headerlink" title="UDP调用connect函数作用"></a>UDP调用connect函数作用</h2><p>&ensp;&ensp;&ensp;&ensp;UDP调用connect函数的作用，并不会引起和服务器目标端的网络交互，也就是说并不会触发所谓的”握手🤝“报文的过程。其主要的作用是让应用程序能够接收到”异步错误“的信息。假设在服务器不开启的情况下，客户端程序是不会报错的，程序会一直阻塞在recvfrom函数上，等待返回或者超时。如果将UDP套接字进行connect绑定，将UDP套接字建立“上下文”，那么这时候操作系统内核接收到的信息就可以和相应的套接字进行相关联。</p>
<h2 id="TCP如何设定超时时间"><a href="#TCP如何设定超时时间" class="headerlink" title="TCP如何设定超时时间"></a>TCP如何设定超时时间</h2><p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/tcp_time_out.png" alt="图片来源于网络"></p>
<p>&ensp;&ensp;&ensp;&ensp;如果TCP握手🤝的SYN超时按照上图来backoff。在Linux中，net.ipv4.tcp_syn_retries参数表示建立TCP连接时SYN报文重试的次数，最多会尝试7次。2的7次幂减去1刚好是127。我们将net.ipv4.tcp_syn_retries参数改成1，就可以将connect超时时间改成3秒。</p>
<p>&ensp;&ensp;&ensp;&ensp;tcp设置发送和接收超时，可以通过SO_SNDTIMEO和SO_RCVTIMEO的选项来设置超时。</p>
<h2 id="SYN-flood洪水攻击"><a href="#SYN-flood洪水攻击" class="headerlink" title="SYN flood洪水攻击"></a>SYN flood洪水攻击</h2><p>&ensp;&ensp;&ensp;&ensp;正常的情况下，TCP需要经过三次握手才能建立连接。于是就出现了对握手🤝，过程进行的攻击。通过发送大量的SYN数据包，服务器响应（SYN+ACK）包。但是这个时候，攻击者不会回应ACK数据包，这个时候服务器不知道发送的（SYN+ACK）包是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存、带宽都会有消耗。如果处于公网地址，攻击者伪造大量的报文进行攻击，那么如果服务器没有任何防护设施的话，可能会直接导致服务器连接资源耗尽，导致拒绝对外服务。</p>
<p>&ensp;&ensp;&ensp;&ensp;从服务器防御的角度来看，可以采取以下措施。</p>
<p>&ensp;&ensp;&ensp;（1）对内核参数进行调优。</p>
<p>&ensp;&ensp;&ensp;（2）利用防火墙禁止掉部分IP。</p>
<p>&ensp;&ensp;&ensp;&ensp;Linux内核参数调优主要从下面几个方面进行：</p>
<p>&ensp;&ensp;&ensp;（1）限制SYN并发的数量，超时时间</p>
<p>&ensp;&ensp;&ensp;（2）增大tcp_max_syn_backblog</p>
<p>&ensp;&ensp;&ensp;&ensp;当半连接的请求数量超过了tcp_max_syn_backlog时，内核就会启用SYN cookie机制，不再把半连接请求放到队列里，而是用SYN cookie来检验。</p>
<p>&ensp;&ensp;&ensp;（3）减小tcp_synack_retries</p>
<p>&ensp;&ensp;&ensp;（4）启用tcp_syncookies</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;SYN cookie是非常巧妙地利用了TCP规范来绕过了TCP连接建立过程的验证过程，从而让服务器的负载可以大大降低在三次握手中，当服务器回应（SYN + ACK）包后，客户端要回应一个n + 1的ACK到服务器。其中n是服务器自己指定的。当启用tcp_syncookies时，backlog满了后，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列backlog里（即没有存储任何关于这个连接的信息，不浪费内存）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。</p>
<h2 id="tcp-粘包半包问题怎么处理？"><a href="#tcp-粘包半包问题怎么处理？" class="headerlink" title="tcp 粘包半包问题怎么处理？"></a>tcp 粘包半包问题怎么处理？</h2><p>粘包与分包的处理方法：</p>
<p>（1）一个是采用分隔符方式。在封装要传输的数据包的时候，采用的固定的符号作为结束符🔚。这样接收到的数据中，如果接收到数据后，出如果出现结尾标识，即进行人为的将粘包分开，如果一个包中没有我们定义的结尾标识符，则是人为出现了分包，则此时我们需要等待下一个数据包进行组包。如HTTP协议以\r\n结尾。</p>
<p>（2）在数据包中添加长度的方式。在数据包的头部或者某个固定的位置封装一个数据包的长度信息。当收到数据包之后，先解析长度然后按照长度截取数据包。</p>
<p>（3）</p>
<h2 id="域套接字比流式套接字快的原因"><a href="#域套接字比流式套接字快的原因" class="headerlink" title="域套接字比流式套接字快的原因"></a>域套接字比流式套接字快的原因</h2><p>域套接字用于同一台计算机上进程间的通信，</p>
<p>1、它仅仅只是复制数据.。</p>
<p>2、不执行协议的处理，不需要增加或删除网络报头。</p>
<p>3、不进行检验和的计算，也不产生序列号，不需要进行校验和的计算</p>
<p>4、无需发送确认报文</p>
<h2 id="tcp的socket怎么收取数据的，recv的返回值。"><a href="#tcp的socket怎么收取数据的，recv的返回值。" class="headerlink" title="tcp的socket怎么收取数据的，recv的返回值。"></a>tcp的socket怎么收取数据的，recv的返回值。</h2><p>TCP收取数据的时候，可以使用函数recv或者read对数据进行读取。</p>
<p>一般的返回值有：</p>
<p>ret  &gt; 0 成功从内核缓冲区读取到的数据大小</p>
<p>ret = 0 TCP连接已经关闭</p>
<p>ret=-1 错误，需要读取错误码进行判断</p>
<p>主要的错误码(errno)有：</p>
<p>EINTR：操作被信号中断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = (<span class="keyword">int</span>)recv(m_socket, pBuf,RECVSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( cnt &gt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">if</span>((cnt&lt;<span class="number">0</span>) &amp;&amp;(errno == EAGAIN||errno == EWOULDBLOCK||errno == EINTR)) </span><br><span class="line">         <span class="comment">//这几种错误码，认为连接是正常的，继续接收</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出接收循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TCP慢启动、拥塞控制、快重传、快恢复"><a href="#TCP慢启动、拥塞控制、快重传、快恢复" class="headerlink" title="TCP慢启动、拥塞控制、快重传、快恢复"></a>TCP慢启动、拥塞控制、快重传、快恢复</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>&ensp;&ensp;&ensp;&ensp;进程：进程是具有一定独立功能的程序关于某一个数据集合的一心运行活动，他是系统进程资源分配和调度的一个基本单位。<br>&ensp;&ensp;&ensp;&ensp;线程：线程是进程的一个实体，他是CPU分配和调度的基本单位。<br><strong>线程的优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;（1）易于调度。<br>&ensp;&ensp;&ensp;&ensp;（2）线程可以提供并发性，利用线程可以有效的实现并发。<br>&ensp;&ensp;&ensp;&ensp;（3）线程开销小。<br>&ensp;&ensp;&ensp;&ensp;（4）有利于发挥对处理器的优点。通过创建多线程，每个线程可以不同的处理器上运行，从而实现应用程序的并行，使得每个处理器都能得到充分发挥。<br><strong>进程与线程的区别</strong>：<br>&ensp;&ensp;&ensp;&ensp;&ensp;(1) 一个线程属于一个进程，而一个进程可以有多个线程。<br>&ensp;&ensp;&ensp;&ensp;（2）一个进程的所有线程共享一个进程的所有资源，这些资源包括有打开的文件，创建的socket，不同的进程是相互独立的<br>&ensp;&ensp;&ensp;&ensp;（3）线程是轻量级进程，进程有进程控制块，线程也有线程控制块。但是线程控制块比进程控制块小的很多，线程切换代价小，进程空间切换代价大，线程空间切换代价小。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p><strong>定义</strong>：<br>&ensp;&ensp;&ensp;&ensp;ps 命令观察进程的执行状态的时候，看到状态栏为defunct状态的进程，这些就是所谓的僵尸进程。<br><strong>僵尸进程的危害</strong><br>&ensp;&ensp;&ensp;&ensp;进程表中占用一个位置（slot）,由于进程表的容量是有限的，所以defunct进程不仅会占用系统资源，影响系统的性能，如果数目太多的话会导致系统的崩溃。<br><strong>僵尸进程产生的原因</strong><br>&ensp;&ensp;&ensp;&ensp;(1)操作系统对所有的进程维护一张进程表，每一个进程在进程表中都有一个entry（进入点），核心程序在执行该进程时候所使用的一切信息都是存储在entry（进入点）中，ps命令查看的就是这个进程表中的相关数据。<br>&ensp;&ensp;&ensp;&ensp;(2)当一个父进程fork()系统调用建立一个新的进程之后，核心进程就会在进程表中给子进程分配一个entry（进入点），然后将这些信息存放在对应的进程表内，这些信息中有一项就是其父进程的识别码。<br>&ensp;&ensp;&ensp;&ensp;(3)当子进程结束之后，其实该没有被真正的销毁，而此时进程表中的数据会被该进程的退出码（exit code），执行所需要的的CPU时间等等数据结构所取代，这些数据会一直保存到父进程读取为止。<br>&ensp;&ensp;&ensp;&ensp;（4）此时，该进程几乎已经放弃所有的把内存空间，没有任何可执行代码，同时也不能被调度，仅仅只是在进程表中保留一个位置，除此之外该进程不占用任何存储空间。该父进程一直没有注册SIGCHILD信号处理函数调用wait或者waitpid等待子进程结束，或者也没有注册忽略该信号，那么这些进程将会变成僵尸进程（zombie），如果父进程一直处于循环状态，系统中就会有很多的僵尸进程。<br><strong>解决的方法</strong><br>&ensp;&ensp;&ensp;&ensp;（1）重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。<br>&ensp;&ensp;&ensp;&ensp;（2）找到僵尸进程的父进程，将父进程杀掉。ps -ef |grep defunct_process_id。<br><strong>如何防止僵尸进程</strong><br>&ensp;&ensp;&ensp;&ensp;（1）父进程fork之前注册之前忽略SIG_CLILD信号，忽略子进程退出相关的信息。调用函数：signal（SIGCHILD, SIG_IGN）。<br>&ensp;&ensp;&ensp;&ensp;（2）父进程调用wait,waitpid函数收集子进程退出的状态码。<br>&ensp;&ensp;&ensp;&ensp;（3）在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程，系统自动回收。<br>##死锁是怎么样产生的##<br><strong>死锁的定义</strong><br>&ensp;&ensp;&ensp;&ensp;系统中有若干个进程在并发运行，他们不断的申请和释放资源，在这一个过程中，由于争夺资源而处于无限期的等待资源的状态，此时导致程序无法继续进行，若无外力的作用，他都将无法推进下去，这是系统处于死锁状态，或者系统产生了死锁。<br><strong>产生死锁的原因</strong><br>&ensp;&ensp;&ensp;&ensp;（1）系统的资源不足，例如多个打印机，但是由于纸张不够，进程推进不下去，产生了死锁。<br>&ensp;&ensp;&ensp;&ensp;（2）进程推进顺序不对。<br>&ensp;&ensp;&ensp;&ensp;（3）资源的分配不当。<br><strong>产生死锁的条件</strong><br>&ensp;&ensp;&ensp;&ensp;（1）互斥性，每个资源每次只能被一个进程使用。<br>&ensp;&ensp;&ensp;&ensp;（2）请求与保持等待，当一个进程因为请求资源而被阻塞等待时，对已经获得的资源保持不释放。<br>&ensp;&ensp;&ensp;&ensp;（3）不可剥夺，进程已经获得资源，未使用完之前，不可被其他剥夺。<br>&ensp;&ensp;&ensp;&ensp;（4）环路等待，若干进程之间 形成首尾相接的的等待资源的关系。</p>
<h2 id="CPU的执行方式"><a href="#CPU的执行方式" class="headerlink" title="CPU的执行方式"></a>CPU的执行方式</h2><p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image3.jpg" alt="图来源于网络"><br>CPU的工作主要分为五个阶段：<br>1、取指令（IF，instruction fetch）。将一条程序执行指令从主存中取出来放到指令寄存器的一个过程。<br>2、指令译码阶段（ID，instruction decode）。取出指令之后，指令译码器按照预定的指令格式对取回的指令进行拆分和解释，识别区分不同的指令类别以及获取各种操作数的方法。<br>3、执行指令的阶段（EX，execute）。具体实现指令的功能，CPU的不同部分被连接起来，以执行所需的操作。<br>4、访问存取数的阶段（MEM，memory）。根据指令的需要访问主存，读取操作数，CPU得到操作数在主存的地址，并从主存中读取该操作数用于运算。<br>5、结果回写阶段（WB，write back）。作为最后一个阶段，结果写回阶段把指令的运行结果数据“写回”到某种存储形式。</p>
<p>资料参考<br><a href="https://www.jianshu.com/p/05c6c1d73144">https://www.jianshu.com/p/05c6c1d73144</a><br><a href="https://www.jianshu.com/p/bfff5d0e718e">https://www.jianshu.com/p/bfff5d0e718e</a></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>资料参考<br><a href="https://blog.csdn.net/Al_xin/article/details/38602093">https://blog.csdn.net/Al_xin/article/details/38602093</a></p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image4.jpg" alt="图来源于网络"><br>32位系统0-4G地址空间，用户空间内存，从低到高分别是五种不同的内存段。<br>1、只读段，主要包括有代码和一些常量。<br>2、数据段，主要包括全局变量。<br>3、堆，主要包括分配的内存，从低地址开始向上增长。<br>4、文件映射段，主要包括动态库、共享内存等，从高地址向下增长。<br>5、栈，包括局部变量，函数的调用的上下文等，栈的大小一般是固定的，一般是8M。<br>在这五个内存段中，堆和文件映射段是动态内存分配的，malloc或者mmap等。<br><strong>堆是线程私有还是共有？栈呢？</strong><br>1、在多线程环境下，每个线程拥有一个栈和一个程序计数器。<br>2、栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。<br>3、其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。</p>
<p>资料参考<br><a href="https://time.geekbang.org/column/article/74272">https://time.geekbang.org/column/article/74272</a></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，指的就是微线程。是应用层的一种概念。</p>
<p>&ensp;&ensp;&ensp;&ensp;协程最大的优势就是具有极高的执行效率。可以把协程看做是一种子程序，因为子程序的切换不是进程也不是线程的切换，因此没有进程或者线程的切换的开销。</p>
<h2 id="列出常见的信号，并解释下信号是怎么处理的。"><a href="#列出常见的信号，并解释下信号是怎么处理的。" class="headerlink" title="列出常见的信号，并解释下信号是怎么处理的。"></a>列出常见的信号，并解释下信号是怎么处理的。</h2><p>&ensp;&ensp;&ensp;&ensp;linux 系统下可以使用命令kill -l查看常见的信号。</p>
<p>&ensp;&ensp;&ensp;&ensp;信号实际上就是一种很短的信息，信号可以被发送到一个进程或者一组进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>不可靠信号：</strong>指的是非实时的信号📶，其中1~31信号就是不可靠信号。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可靠信号：</strong>指的是实时的信号，其中32~64信号是可靠信号📶。</p>
<p>&ensp;&ensp;&ensp;&ensp;可靠信号与不可靠信号的区别在于：不可靠信号不支持排队，可能会造成信号丢失，但是可靠信号不会。如果一个不可靠的信号📶被连续发送多次，那么只有其中的一个会被发送到接收进城。</p>
<p>&ensp;&ensp;&ensp;&ensp;内核给进程发送信号📶，实在进程所在的进程表项的信号阈设置相应的信号的位。</p>
<p>&ensp;&ensp;&ensp;&ensp;进程检查信号的时机是：进程即将从内核态返回用户态的时候。如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则是进行唤醒。</p>
<h2 id="i-或者-i是否是原子操作，为什么。"><a href="#i-或者-i是否是原子操作，为什么。" class="headerlink" title="i++或者++i是否是原子操作，为什么。"></a>i++或者++i是否是原子操作，为什么。</h2><p>&ensp;&ensp;&ensp;&ensp;这个不是原子操作。因为i++这个可以在拆分为三个过程。</p>
<p>&ensp;&ensp;&ensp;&ensp;1、内存到寄存器</p>
<p>&ensp;&ensp;&ensp;&ensp;2、寄存器自增</p>
<p>&ensp;&ensp;&ensp;&ensp;3、写回内存。</p>
<p>&ensp;&ensp;&ensp;&ensp;这其中的任何一个阶段都有可能会被中断。</p>
<p>&ensp;&ensp;&ensp;&ensp;++i这个其实在多核处理器上，CPU在读取内存时候，也会可能发生同时读取到一个值，这样其实也会导致两次自增，实际上只是增加了一次。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以，i++和++i都是不是原子操作。</p>
<h2 id="linux下的同步机制，以及死锁，如何避免死锁。"><a href="#linux下的同步机制，以及死锁，如何避免死锁。" class="headerlink" title="linux下的同步机制，以及死锁，如何避免死锁。"></a>linux下的同步机制，以及死锁，如何避免死锁。</h2><p>&ensp;&ensp;&ensp;&ensp;1、原子操作。原子操作不会被任何事物所打断，通常用于资源的计数，引用的计数。例如有TCP/IP协议栈的IP碎片计数。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、信号量。就像房间内有好几把钥匙🗝，拿到钥匙就去访问。设置为1的时候变为了mutex。绝大多数部分可以作为互斥锁来进行使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、读写信号量。可以允许多个读，一个写。一旦有人在写，就大家都不可以读取，如果没有在写，可以允许多个人进行读取。</p>
<p>&ensp;&ensp;&ensp;&ensp;4、锁🔐。自旋锁和互斥锁的区别在于是否会进行休眠。如果自旋锁被其他执行单元持有，那么调用者就会一直在那自旋，循环等待资源的释放。在持有时间很短的情况下一般使用自旋锁会比互斥锁稍微高效一些。</p>
<p><strong>死锁产生的必要条件：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1、资源一定是互斥的。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、资源是不可抢占的。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、占有且需要申请的。</p>
<p>&ensp;&ensp;&ensp;&ensp;4、需要循环等待的。</p>
<h2 id="exit和-exit-EXIT-的区别"><a href="#exit和-exit-EXIT-的区别" class="headerlink" title="exit和_exit(_EXIT)的区别"></a>exit和_exit(_EXIT)的区别</h2><p>&ensp;&ensp;&ensp;&ensp;_exit和_EXIT函数调用时候立即进入内核，exit函数则是会先进行一些清理处理，然后再返回内核。</p>
<p>&ensp;&ensp;&ensp;&ensp;exit函数总是会先执行一个标准的I/O库的清理关闭操作，对于所有打开流调用fclose函数，会将输出缓冲区中的所有数据都被冲洗。</p>
<p>&ensp;&ensp;&ensp;&ensp;_exit函数调用则是直接关闭文件📃，文件缓冲区中的内容也就直接消失了，这个时候是不会再输出到显示设备了。</p>
<h2 id="linux内存管理机制"><a href="#linux内存管理机制" class="headerlink" title="linux内存管理机制"></a>linux内存管理机制</h2><p>&ensp;&ensp;&ensp;&ensp;linux操作系统采用虚拟内存管理技术，将不同进程的虚拟地址空间和不同的内存物理地址映射起来，使得每个进程都有各自互不干扰的进程地址空间。</p>
<p>&ensp;&ensp;&ensp;&ensp;在32位的系统上该空间的大小为4G的现行虚拟空间，用户所看到的或者接触的都是虚拟地址空间，并不会看到实际的物理地址。操作系统引入了虚拟内存，那么进程持有的虚拟地址就会通过CPU的内存管理单元（MMU）的映射关系，转化成物理地址，然后再通过物理地址进程访问。只有那些实际使用的UNINEICUN才分配物理内存，并且分配之后的物理内存是通过内存映射来管理的。</p>
<p>&ensp;&ensp;&ensp;&ensp;内存映射，其实就是讲虚拟内存地址映射到物理内存地址，为了完成内存映射，内核为每一个进程都维护了一张页表，记录虚拟地址与物理地址之间的映射关系。页表实际上存储在CPU的内存管理单元MMU中，这样情况下，处理器可以直接通过硬件找出需要访问的内存。当进程访问虚拟地址在页表中查询不到的时候，系统就会产生一个缺页异常，进入到内核空间进行分配物理内存，更新进程页表，最后返回到用户空间，回复进程的运行。</p>
<p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/mmu.jpg" alt="图来源于网络"></p>
<p>&ensp;&ensp;&ensp;&ensp;MMU并不是以字节为单位来管理内存的，而是规定了一乐内存映射的最小单位，页。通常是4KB大小，这样每一个内存映射，都需要关联4KB或者4KB的整数倍的内存空间。</p>
<p><strong>多级页表</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;多级页表就是把内存分成区块来进行管理，将原来的映射关系改成区块索引和区块偏移。由于虚拟地址空间通常只用很少的一部分，那么多级页表就只保存这些使用的区块，这样就可以大大的减少页表的项数。</p>
<p>Linux是用过四级页表来管理内存的，如下图。虚拟地址被分为5个部分，前四个表项用于选择页，而最后一个表项这是索引表示页内偏移。</p>
<p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/ye_biao.jpg" alt="图片来源于网络"></p>
<p>再看大页，大页指的是比普通页更大的内存块，常见的大小有2MB和1GB。大页通常用在使用大量内存的进程上，比如Oracle、DPDK等。</p>
<p><strong>内存的分配与回收♻️</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;在C标准库中，malloc是其提供的内存分配函数，对应的系统调用上主要有两种实现的方式，即brk()和mmap()。</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）对于小块的内存，C标准库使用brk()来进行分配，也就是通过移动堆顶的位置来进行分配内存，这些内存释放之后不会立刻归还给系统，而是会被缓存起来，这样可以重复使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）对于大块的内存（大于128K），则是使用内内存映射mmap()来进行分配，也就是在文件映射段找到一块空闲的内内存分配出去。</p>
<p>这两种方式的优缺点：</p>
<p>&ensp;&ensp;&ensp;&ensp;brk()方式的缓存，可以减少却也一行的发生，可以提高内存的访问效率，不过，由于这些内存没有归还给系统，在内存繁忙的时候，频繁的内存分配和释放会造成内存碎片。</p>
<p>&ensp;&ensp;&ensp;&ensp;mmap（）方式的分配内存，会在释放时候直接归还给系统，所以每次mmap都会发生缺页异常。在内存工作繁忙的时候，频繁的内存分配会导致大量的缺页异常的发生，使得内存的管理负担增大，这也是malloc只对大块内存使用mmap的原因。</p>
<p>&ensp;&ensp;&ensp;&ensp;了解了这两种，调用方式之后，我们还需要清楚的了解一点，就是当发生这两种调用方式之后，其实没有镇长的分配内存，这些实际使用的内存，只有在首次访问的时候才进行分配，也就是通过缺页异常进入到内核中，再由内核进行分配内存。</p>
<h2 id="Linux的任务调度机制"><a href="#Linux的任务调度机制" class="headerlink" title="Linux的任务调度机制"></a>Linux的任务调度机制</h2><p>&ensp;&ensp;&ensp;&ensp;&ensp;Linux作为一个多任务的操作系统，必须支持程序的并发执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;多任务一般分为两类，非抢占式多任务与抢占式多任务。</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;&ensp;非抢占式多任务：</strong>除非任务自己结束🔚，否则将会一直执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>抢占式多任务：</strong>这种情况下，由调度程序来决定什么时候停止一个进程的运行，这个强制的挂起动作则是<strong>抢占</strong>。抢占式多任务的基础就是使用<strong>时间片轮转</strong>机制来为每一个进程分配可以运行的时间单位。</p>
<p><strong>策略：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>I/O消耗性和CPU消耗形。</strong>为了保证交互式桌面系统的性能，linux一般更倾向于优先调度I/O消耗形的进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>进程优先级。</strong>Linux采用两种不同的优先级范围。</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）使用nice值：越大的nice值意味着更低的优先级。（-19~20之间）</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）实时优先级：可以配置，越高表示进程的优先级越高。</p>
<h2 id="标准库函数和系统调用的区别"><a href="#标准库函数和系统调用的区别" class="headerlink" title="标准库函数和系统调用的区别"></a>标准库函数和系统调用的区别</h2><p>&ensp;&ensp;&ensp;&ensp;标准库函数，是语言本身的一部分，系统函数则是内核提供给应用层程序的一个接口，属于系统的一部分。函数库调用是语言或者应用程序的一部分，而系统调用则是操作系统的一部分。</p>
<p>&ensp;&ensp;&ensp;&ensp;系统调用通常用于<strong>底层文件访问（low-level file access）</strong>，例如在驱动程序中对设备文件的直接访问。</p>
<p>&ensp;&ensp;&ensp;&ensp;系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。</p>
<h2 id="如何查看进程打开的文件"><a href="#如何查看进程打开的文件" class="headerlink" title="如何查看进程打开的文件"></a>如何查看进程打开的文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、查看谁正在使用某个文件</span><br><span class="line">lsof /filepath/file</span><br><span class="line"></span><br><span class="line">2、通过某个进程号显示该进行打开的文件</span><br><span class="line">lsof -p 1</span><br></pre></td></tr></table></figure>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zhangye3017/article/details/80382496</span></span><br></pre></td></tr></table></figure>


<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="memcpy比较两个结构体"><a href="#memcpy比较两个结构体" class="headerlink" title="memcpy比较两个结构体"></a>memcpy比较两个结构体</h2><p>不能。结构体struct 对象由于内存对齐会有内存间隙，就算其中的成员变量相等，内存直接比较还是不能相等。</p>
<p>1、结构体赋值之前可以初始化memset一下，然后可以用memcpy来进行对比，（如果有指针的话 不行）</p>
<p>2、可以使用运算符重载进行成员一一比较，看看变量是否相等。</p>
<p>每个<strong>特定平台</strong>上的编译器都有自己的默认“<strong>对齐系数</strong>”。可以通过预编译命令#pragma pack(n)</p>
<p>在经过对齐原则分析后，检查计算出的存储单元是否为所有元素中所占内存最大的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。</p>
<h2 id="strcpy与memcpy的区别"><a href="#strcpy与memcpy的区别" class="headerlink" title="strcpy与memcpy的区别"></a>strcpy与memcpy的区别</h2><p>1、一个是字符串拷贝函数一个是内存拷贝函数</p>
<p>2、strcpy无需制定长度，遇到’\0’结束，无法复制0值</p>
<p>3、memcpy是内存拷贝函数，将制定长度的字节直接整个拷贝不进行内容检查。</p>
<p>4、strcpy是不安全字符串操作函数，如果参数dest所指定的内存空间不够大，那么久会出现缓冲区溢出问题，严重的话会导致程序崩溃。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><strong>Redis内存数据库的内存指的是共享内存么</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;Redis 是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说 Redis 是实现网站高并发不可或缺的一部分，并不是指在一定只是在共享内存存取数据。</p>
<h2 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h2><p>Redis的持久化方式主要有两种RDB和AOF两种。<br>&ensp;&ensp;&ensp;&ensp;RDB持久化是在一定的时间间隔内生成内存数据集的时间点的一个快照。<br>&ensp;&ensp;&ensp;&ensp;AOF持久化则是记录服务器执行的所有写操作命令，并且在服务器启动的时候，通过执行这些命令来对数据进行还原。<br><strong>RDB的优点</strong><br>&ensp;&ensp;&ensp;&ensp;1、采用RDB方式持久化，整个redis数据库将会只包含一个文件，对于这个备份文件来说很完美的。一旦系统出现故障，我们可以很快的进行恢复。<br>&ensp;&ensp;&ensp;&ensp;2、对于灾难恢复，RDB是一个不错的选择，可以压缩成 其他格式进行存储。<br>&ensp;&ensp;&ensp;&ensp;3、能使性能最大化。在进行持久化之时候，只需要fork一个子进程进行持久化工作，这样服务进程就能极大的避免进行IO操作。<br>&ensp;&ensp;&ensp;&ensp;4、相对于AOF而言，如果数据库的数据集很大的话，RDB的启动效率会高一些。<br><strong>RDB的缺点</strong><br>主要有两点：<br>&ensp;&ensp;&ensp;&ensp;1、在持久化任务进行之前，如果系统出现宕机，那么此前还没有进行持久化写入磁盘的数据将会丢失，对于数据的高可用性、完整性要求比较高的场景这种持久化的方式将不会是一个很好的选择。<br>&ensp;&ensp;&ensp;&ensp;2、因为RDB是通过fork子进程来进行协助完成持久化，如果数据集特别大的话，可能这个时候服务器会停止服务几百毫秒甚至一秒。<br><strong>AOF的优点</strong><br>&ensp;&ensp;&ensp;&ensp;1、相比于RDB有更好的数据安全性和数据持久性。在redis中主要提供了三种同步策略，每秒同步，每修改同步，还有不同同步。<br>&ensp;&ensp;&ensp;&ensp;2、由于这个机制对日志文件的写入操作是以append追加的方式进行。所以即使系统宕机了也不会破坏日志文件中已经存在的内容。<br>&ensp;&ensp;&ensp;&ensp;3、AOF日志文件中包含了对数据库的所有修改操作，我们可以通过该日志文件完成数据的重建。<br><strong>AOF的缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1、对于相同的数据集而言，AOF文件通常大于RDB文件，在进行数据恢复的时候速通常比RDB慢。<br>&ensp;&ensp;&ensp;&ensp;2、根据同步的策略，AOF在运行效率上往往会慢于RDB。</p>
<h2 id="持久化方式的选择"><a href="#持久化方式的选择" class="headerlink" title="持久化方式的选择"></a>持久化方式的选择</h2><p>&ensp;&ensp;&ensp;&ensp;1、对于数据一致性要求比较高的场景，建议使用使用AOF。<br>&ensp;&ensp;&ensp;&ensp;2、对于数据丢失的一部分没有那么看重的话，建议选择RDB。<br>&ensp;&ensp;&ensp;&ensp;3、如果对于数据的一致性、完整性特别重视，建议两种都开启。<br>&ensp;&ensp;&ensp;&ensp;4、AOF方式在不开启fsync的时候，性能和RDB相当。建议开启AOF方式的每秒钟同步一次。</p>
<h2 id="redis和mysql有什么区别，用于什么场景"><a href="#redis和mysql有什么区别，用于什么场景" class="headerlink" title="redis和mysql有什么区别，用于什么场景"></a>redis和mysql有什么区别，用于什么场景</h2><p>&ensp;&ensp;&ensp;&ensp;1、redis 基于内存，读写速度快，可以持久化但是内存空间有限，数据量超过内存空间时，需要进行扩充内存。<br>&ensp;&ensp;&ensp;&ensp;2、MySQL则是磁盘存储，读写相对于redis扫稍慢些，但是不受空间容量限制，性价比高。</p>
<p>&ensp;&ensp;&ensp;&ensp;在大多数的场景下都是MySQL+Redis配合使用，MySQL作为主存储库，Redis用作缓存可以加快访问速度。在需要高性能的地方使用Redis在不需要的高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步。</p>
<p>&ensp;&ensp;&ensp;&ensp;使用Redis缓存到MySQL。可以把表中经常访问的数据记录在Redis中，在需要查询数据的时候，先去Redis查询，如果查询不到再去MySQL中进行查找，这样可以实现读写分离。现在的软件大量的软件使用Redis作为MySQL在本地的缓存数据库，再适当的时候和MySQL同步。</p>
<h2 id="Redis缓存更新的模式以及出现的问题和应对思路"><a href="#Redis缓存更新的模式以及出现的问题和应对思路" class="headerlink" title="Redis缓存更新的模式以及出现的问题和应对思路"></a>Redis缓存更新的模式以及出现的问题和应对思路</h2><p>首先了解三个概念。<br>&ensp;&ensp;&ensp;&ensp;1、缓存雪崩<br>&ensp;&ensp;&ensp;&ensp;2、缓存穿透<br>&ensp;&ensp;&ensp;&ensp;3、缓存击穿<br><strong>缓存雪崩</strong><br>&ensp;&ensp;&ensp;&ensp;目前电商的首页以及热点的数据都会去做缓存，一般的缓存都是定时任务去更新或者说是查不到数据之后去数据库更新，在这里定时更新就会可能出现问题。缓存雪崩就是同一时间内大量的key值失效的瞬间或者同一瞬间大面积的请求数据库。这一瞬间，Redis缓存和没有一样，这个时候这个数量级别的请求直接打在数据库上几乎就是灾难性的。这就是缓存雪崩。</p>
<p>应对思路：在批量往Redis存储数据的时候，需要把每个key的失效时间都加个随机值就好了，这样可以保证同一时间大面积失效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">setRedis(key, values, time+Math.random()*<span class="number">10000</span>)	</span><br></pre></td></tr></table></figure>
<p><strong>缓存穿透</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓存穿透，指的是缓存和数据库中都没有请求的数据，而且用户却不断发起请求，导致数据库压力大，严重时候会直接击垮数据库。</p>
<p>应对思路：接口层做参数校验，比如用户授权检验，参数做校验，对于不符合的数据直接return返回。对于Java来说，还有个高级的用法采用<em><strong>布隆过滤器（Bloom Filter）</strong></em>这个也可以很好的防止缓存穿透的发生，他的原理就是利用高效的数据结构和算法快速判断这个key在数据库中是否存在。</p>
<p><strong>缓存击穿</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓存击穿和和缓存雪崩有点类似，但是两者有点区别。雪崩是因为大面积缓存失效，打崩数据库。缓存击穿则是指的是一个key非常热点，在不停的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库，就像在一个完好无损的桶上开了一个洞。</p>
<p>应对思路：设置热点数据永不过期，或者加上互斥锁🔐就可以解决这个问题。</p>
<h2 id="Redis的hash是什么实现的"><a href="#Redis的hash是什么实现的" class="headerlink" title="Redis的hash是什么实现的"></a>Redis的hash是什么实现的</h2><p>&ensp;&ensp;&ensp;&ensp;Redis中的字典采用哈希表作为底层实现，一个哈希表多个节点，每个节点保存一个键值对。Redis数据库就是使用字典作为底层实现的，通过key和value的键值对形式，代表了数据库中的全部数据。而且对数据库的增删改查都是建立在对字典的操作上。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、<a href="https://blog.csdn.net/xp731574722/article/details/82868560">https://blog.csdn.net/xp731574722/article/details/82868560</a></p>
<p>2、<a href="https://blog.csdn.net/kozazyh/article/details/5495532">https://blog.csdn.net/kozazyh/article/details/5495532</a></p>
<p>3、<a href="https://blog.csdn.net/zhangye3017/article/details/80382496">https://blog.csdn.net/zhangye3017/article/details/80382496</a></p>
]]></content>
      <categories>
        <category>面试宝典</category>
      </categories>
  </entry>
</search>
