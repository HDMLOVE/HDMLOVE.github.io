<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Suzette219</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Suzette219">
<meta property="og:url" content="http://www.lpyuan.club/page/2/index.html">
<meta property="og:site_name" content="Suzette219">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="发量充足的程序员">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Suzette219" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Suzette219</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.lpyuan.club"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Go语言学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-11-29T06:57:10.348Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">Go语言学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h1><h2 id="Go语言错误处理"><a href="#Go语言错误处理" class="headerlink" title="Go语言错误处理"></a>Go语言错误处理</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 封装Go 防止野生的goruntime panic导致程序挂掉 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Go</span><span class="params">(x <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		x()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"he"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"lpyuan2"</span>)</span><br><span class="line">		fmt.Println(<span class="string">"aaa"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"lpyuan1"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第3章-基本的数据类型"><a href="#第3章-基本的数据类型" class="headerlink" title="第3章 基本的数据类型"></a>第3章 基本的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四大类型：</span><br><span class="line">1、基础数据类型(basic type)</span><br><span class="line">2、聚合类型(aggregate type)</span><br><span class="line">3、引用类型(reference type)</span><br><span class="line">4、接口类型(interface type)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基础的数据类型：</span><br><span class="line">1、数字、字符串、布尔型</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/11/29/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" data-id="cklan5l720003180r6ckc9gk2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-腾讯面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/16/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2020-11-15T23:52:08.020Z" itemprop="datePublished">2020-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/16/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/">腾讯面试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、100万数据个是topK。</p>
<p>2、32位无符号整形个数的QQ号记录QQ号的状态 上线和下线，计算使用多少内存。</p>
<p>3、printf(“%d “, 1, 2, 3);  printf(“%s”)；</p>
<p>4、HTTP 和 HTTPS的区别。1、对称加密和非对称加密。2、效率问题的瓶颈。</p>
<p>5、阻塞问题</p>
<p>1、对端接收处理不过来 。流量控制。</p>
<p>2、网络阻塞。拥塞控制。</p>
<p>3、项目问题</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/11/16/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95/" data-id="cklan5l7r0013180rc41g74tk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-生活" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/13/%E7%94%9F%E6%B4%BB/" class="article-date">
  <time datetime="2020-10-13T13:13:19.000Z" itemprop="datePublished">2020-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/13/%E7%94%9F%E6%B4%BB/">人为什么活着</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="你喜欢的人在努力，你却在想怎么说我爱你"><a href="#你喜欢的人在努力，你却在想怎么说我爱你" class="headerlink" title="你喜欢的人在努力，你却在想怎么说我爱你"></a>你喜欢的人在努力，你却在想怎么说我爱你</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/10/13/%E7%94%9F%E6%B4%BB/" data-id="cklan5l7o000v180rbvrv3g03" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-汇编语言笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-10-11T01:18:11.910Z" itemprop="datePublished">2020-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/">汇编语言笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h2 id="三大总线"><a href="#三大总线" class="headerlink" title="三大总线"></a>三大总线</h2><p>1、地址总线</p>
<p>2、控制总线</p>
<p>3、数据总线</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" data-id="cklan5l7m000q180r42nv7t7f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编写Makefile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/06/%E7%BC%96%E5%86%99Makefile/" class="article-date">
  <time datetime="2020-10-05T22:10:54.957Z" itemprop="datePublished">2020-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/06/%E7%BC%96%E5%86%99Makefile/">编写Makefile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="编写Makefile文件"><a href="#编写Makefile文件" class="headerlink" title="编写Makefile文件"></a>编写Makefile文件</h1><hr>
<p>&ensp;&ensp;&ensp;&ensp;Makefile编写的好可以在工程项目编译链接的过程中省去很多麻烦，平时在练习的过程中也是能方便高效的学习。</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<h2 id="一、Makefile相关知识点"><a href="#一、Makefile相关知识点" class="headerlink" title="一、Makefile相关知识点"></a>一、Makefile相关知识点</h2><p>&ensp;&ensp;&ensp;&ensp;需要掌握的一些Makefile相关的基础知识。</p>
<h3 id="1-忽略出错的命令。"><a href="#1-忽略出错的命令。" class="headerlink" title="1. 忽略出错的命令。"></a>1. 忽略出错的命令。</h3><p>&ensp;&ensp;&ensp;&ensp;如果不希望某条命令因为出错了而导致整个make执行被终止，可以在命令前面加上“-”，表示不管该命令出不出错，后面的命令都将继续执行下去。如：<br>&ensp;&ensp;&ensp;&ensp;mkdir lpyuan<br>&ensp;&ensp;&ensp;&ensp;如果不加“-”并且dir已经存在，则这条命令就会出错，并将导致整个make执行被终止。要想不被终止，则需要在前加上’-‘符号。<br>&ensp;&ensp;&ensp;&ensp;-mkdir dir</p>
<h3 id="2-显示命令。"><a href="#2-显示命令。" class="headerlink" title="2. 显示命令。"></a>2. 显示命令。</h3><p>&ensp;&ensp;&ensp;&ensp;一般默认make会把命令原样显示出来后再去执行命令，如果我们不需要原样显示命令，则可以在命令前面加一个“@”， 如<br>&ensp;&ensp;&ensp;&ensp;@m -rf lpyuan<br>&ensp;&ensp;&ensp;&ensp;则是不会输出命令。</p>
<h3 id="3-符号。"><a href="#3-符号。" class="headerlink" title="3. 符号。"></a>3. 符号。</h3><p>&ensp;&ensp;&ensp;&ensp;$@  表示目标文件<br>&ensp;&ensp;&ensp;&ensp;$^  表示所有的依赖文件<br>&ensp;&ensp;&ensp;&ensp;$&lt;  表示第一个依赖文件<br>&ensp;&ensp;&ensp;&ensp;$?  表示比目标还要新的依赖文件列表</p>
<p>如一个目录下有如下文件：<br>&ensp;&ensp;&ensp;&ensp;hello.c&ensp;&ensp;hi.c&ensp;&ensp;main.c&ensp;&ensp;Makefile<br>按照 Makefile 规则规规矩矩的写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main: main.o hello.o hi.o</span></span><br><span class="line">        gcc -o main main.o hello.o hi.o</span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">        cc -c main.c</span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">        cc -c hello.c</span><br><span class="line"><span class="section">hi.o: hi.c</span></span><br><span class="line">        cc -c hi.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o</span><br><span class="line">        rm main</span><br><span class="line">        </span><br><span class="line">改为用上述符号进行替代：</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o hello.o hi.o</span></span><br><span class="line">        gcc -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">hi.o: hi.c</span></span><br><span class="line">        cc -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o</span><br><span class="line">        rm main</span><br></pre></td></tr></table></figure>

<h3 id="4-Makefile中的常用函数。"><a href="#4-Makefile中的常用函数。" class="headerlink" title="4. Makefile中的常用函数。"></a>4. Makefile中的常用函数。</h3><h4 id="4-1-函数名称-：反过滤函数—filter-out。"><a href="#4-1-函数名称-：反过滤函数—filter-out。" class="headerlink" title="4.1 函数名称 ：反过滤函数—filter-out。"></a>4.1 函数名称 ：反过滤函数—filter-out。</h4><p>格式：$(filter-out PATTERN…,TEXT)<br>函数功能 ：和“filter”函数实现的功能相反。过滤掉字串“TEXT”中所有符合“PATTERN”的单词，保留所有不符合的单词。可以多个模式。存在多模式时，模式表达式之间使用空格分割。<br>返回值 ：空格分割的“TEXT”字串中所有不符合模式“PATTERN”的字串。<br>函数说明： “filter-out”函数也可以用来去除一个变量中的某些字符串（实现和“filter”函数相反）。<br>下面有个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects&#x3D;main1.o foo.o main2.o bar.o </span><br><span class="line">mains&#x3D;main1.o main2.o</span><br><span class="line">$(filter-out$(mains),$(objects))</span><br><span class="line">实现了去除变量&quot;objects&quot;中&quot;mains&quot;定义的字串（文件名）功能。它的返回值为&quot;foo.o bar.o&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="二、Makefile通用模板"><a href="#二、Makefile通用模板" class="headerlink" title="二、Makefile通用模板"></a>二、Makefile通用模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">TARGET&#x3D;server</span><br><span class="line">CC&#x3D;g++</span><br><span class="line">CFLAG&#x3D;-c -g -static</span><br><span class="line">#所有的.c文件</span><br><span class="line">SRCS:&#x3D;$(wildcard ..&#x2F;*.c)</span><br><span class="line">FILTERS&#x3D;..&#x2F;hello.c</span><br><span class="line">#从SRCS中除了hello.c文件 filter函数可以选择满足条件的</span><br><span class="line">SRCS:&#x3D;$(filter-out $(FILTERS), $(SRCS))</span><br><span class="line">OBJS:&#x3D;$(patsubst %.c, %.o, $(SRCS))</span><br><span class="line">CURRENT_PATH&#x3D;$(PWD)</span><br><span class="line">CPPFLAGS&#x3D; -I..&#x2F;include -I..&#x2F;util</span><br><span class="line">LIBS_PATH&#x3D;-L..&#x2F;lib64</span><br><span class="line">LIBS&#x3D;-lmylib</span><br><span class="line"></span><br><span class="line">#判断是哪个系统32bit编译还是在64bit编译。</span><br><span class="line">ARCH:&#x3D;$(shell uname -m)</span><br><span class="line">ifeq ($(ARCH), x86_64)</span><br><span class="line">VERSION:&#x3D;X86_64</span><br><span class="line">else</span><br><span class="line">VERSION:&#x3D;i686</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(TARGET):$(OBJS)</span><br><span class="line">        $(CC) $(DEBUG) $(SRCS) $(LIBS_PATH) $(LIBS) $(CPPFLAGS) -o $(TARGET)</span><br><span class="line"></span><br><span class="line">$(OBJS):%.o:%.c</span><br><span class="line">        $(CC) $(CFLAG) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">.PHONY:clean</span><br><span class="line">clean:</span><br><span class="line">        rm -rf *~ *.bak $(TARGET)</span><br><span class="line"></span><br><span class="line">【顶层Makefile编写】</span><br><span class="line">all: all_client all_server</span><br><span class="line">    rm -rf *~ *.bak</span><br><span class="line">all_client:</span><br><span class="line">    $(MAKE) -C client</span><br><span class="line">all_server:</span><br><span class="line">    $(MAKE) -C server</span><br><span class="line"></span><br><span class="line">clean: clean_client clean_server</span><br><span class="line">    rm -rf *~ *.bak</span><br><span class="line">clean_client:</span><br><span class="line">    $(MAKE) -C client clean</span><br><span class="line">clean_server:</span><br><span class="line">    $(MAKE) -C server clean</span><br></pre></td></tr></table></figure>

<hr>
<p>感谢您花费时间阅读这篇文章，书中有错误的地方或者有什么建议都可以留言，或者通过邮件祝您在这里记录、阅读、分享愉快！</p>
<p>作&ensp;者:&ensp;lpyuan<br>Email:&ensp;<a href="mailto:lpyuan21@outlook.com">lpyuan21@outlook.com</a><br>2020年02月28日 02:52:00   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/10/06/%E7%BC%96%E5%86%99Makefile/" data-id="cklan5l7q0010180rgkob5yom" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/06/hello-world/" class="article-date">
  <time datetime="2020-10-05T22:05:26.619Z" itemprop="datePublished">2020-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/06/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/10/06/hello-world/" data-id="cklan5l7h000j180r5k0m85g0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-面试笔试" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/" class="article-date">
  <time datetime="2020-03-13T14:27:24.000Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/">面试笔试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="大端小端网络字节序"><a href="#大端小端网络字节序" class="headerlink" title="大端小端网络字节序"></a>大端小端网络字节序</h2><p>&ensp;&ensp;&ensp;&ensp;”大端”，”小端”指的是表示多字节的值哪一端存储在该值的起始地址处；多字节小端存储起始地址处称为小端字节序，多字节的大端存储在起始地址处称为大端字节序。<br>&ensp;&ensp;&ensp;&ensp;通俗的说就是。</p>
<p>&ensp;&ensp;&ensp;&ensp;常用的X86架构就是采用的小端存储，最高有效位在最高位地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;大端字节序：最高有效位存于最低的内存地址，最低的有效位存于最高的内存地址。<br>&ensp;&ensp;&ensp;&ensp;小端字节序：最高有效位存于最高的内存地址，最低的有效位存于最低的内存地址。<br><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image1.jpg" alt="图来源于网络"><br>&ensp;&ensp;&ensp;&ensp;网络字节序，网络上传输的数据都是字节流。<strong>UDP/TCP/IP协议规定:</strong>把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节。而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,<strong>多字节数值在发送之前,在内存中因该是以大端法存放的</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">union 联合体成员存放的顺序都是从低地址开始存放，并且是所有的成员共享同一个内存空间，</span></span><br><span class="line"><span class="comment">可以利用这个特性进行一个大小端的判断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义联合体结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _testUnion&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">&#125;testUnion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断大小端 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isBigEndStorage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testUnion a;</span><br><span class="line">    a.a = <span class="number">0x01</span>;</span><br><span class="line">    <span class="keyword">return</span> a.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> == isBigEndStorage())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"小端存储"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"大端存储"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h2><p>&ensp;&ensp;&ensp;&ensp;为什么建立连接需要三次握手？TCP的两次握手是最基本的，第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。<br>&ensp;&ensp;&ensp;&ensp;客户端只有确定了自己能与服务端连接上才能开始发数据。所以两次握手肯定是最基本的。<br>&ensp;&ensp;&ensp;&ensp;到了这，有人肯定又有疑问，两次握手不就可以了吗，为什么需要第三次握手。其实，第三次握手主要的原因是防止已经失效的连接请求报文由于某种原因突然又回到服务端，从而就会产生错误。比如，一个请求的数据包，因为某些原因滞留在网络中很久，一直到了连接释放的时候才到达服务端，这时候，服务端以为是客户端的第一次连接回应了客户端从而建立了连接，实际上是不必要的连接客户端并没有任何数据要发送，当存在大量的这种情况下，会造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。<br><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image2.jpg" alt="图来源于网络"></p>
<h2 id="TCP与UDP的概念"><a href="#TCP与UDP的概念" class="headerlink" title="TCP与UDP的概念"></a>TCP与UDP的概念</h2><p>&ensp;&ensp;&ensp;&ensp;TCP:一种面向连接的，可靠的，基于字节流的通信协议。<br>&ensp;&ensp;&ensp;&ensp;UDP:提供无连接的通信，不可靠的，基于数据报的通信协议。<br><strong>两者的主要区别是</strong>：<br>&ensp;&ensp;&ensp;&ensp;（1）TCP是面向连接的传输控制协议，而UDP是提供无连接的数据报服务。<br>&ensp;&ensp;&ensp;&ensp;（2）TCP具有高可靠性，能确保数据的完整性和正确性。<br>&ensp;&ensp;&ensp;&ensp;（3）TCP需要的系统资源比较多，而UDP需要的就相对少一些。<br>&ensp;&ensp;&ensp;&ensp;（4）UDP实时性比较高，低延迟，但是TCP的工作效率相对高一些。</p>
<h2 id="UDP调用connect函数作用"><a href="#UDP调用connect函数作用" class="headerlink" title="UDP调用connect函数作用"></a>UDP调用connect函数作用</h2><p>&ensp;&ensp;&ensp;&ensp;UDP调用connect函数的作用，并不会引起和服务器目标端的网络交互，也就是说并不会触发所谓的”握手🤝“报文的过程。其主要的作用是让应用程序能够接收到”异步错误“的信息。假设在服务器不开启的情况下，客户端程序是不会报错的，程序会一直阻塞在recvfrom函数上，等待返回或者超时。如果将UDP套接字进行connect绑定，将UDP套接字建立“上下文”，那么这时候操作系统内核接收到的信息就可以和相应的套接字进行相关联。</p>
<h2 id="TCP如何设定超时时间"><a href="#TCP如何设定超时时间" class="headerlink" title="TCP如何设定超时时间"></a>TCP如何设定超时时间</h2><p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/tcp_time_out.png" alt="图片来源于网络"></p>
<p>&ensp;&ensp;&ensp;&ensp;如果TCP握手🤝的SYN超时按照上图来backoff。在Linux中，net.ipv4.tcp_syn_retries参数表示建立TCP连接时SYN报文重试的次数，最多会尝试7次。2的7次幂减去1刚好是127。我们将net.ipv4.tcp_syn_retries参数改成1，就可以将connect超时时间改成3秒。</p>
<p>&ensp;&ensp;&ensp;&ensp;tcp设置发送和接收超时，可以通过SO_SNDTIMEO和SO_RCVTIMEO的选项来设置超时。</p>
<h2 id="SYN-flood洪水攻击"><a href="#SYN-flood洪水攻击" class="headerlink" title="SYN flood洪水攻击"></a>SYN flood洪水攻击</h2><p>&ensp;&ensp;&ensp;&ensp;正常的情况下，TCP需要经过三次握手才能建立连接。于是就出现了对握手🤝，过程进行的攻击。通过发送大量的SYN数据包，服务器响应（SYN+ACK）包。但是这个时候，攻击者不会回应ACK数据包，这个时候服务器不知道发送的（SYN+ACK）包是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存、带宽都会有消耗。如果处于公网地址，攻击者伪造大量的报文进行攻击，那么如果服务器没有任何防护设施的话，可能会直接导致服务器连接资源耗尽，导致拒绝对外服务。</p>
<p>&ensp;&ensp;&ensp;&ensp;从服务器防御的角度来看，可以采取以下措施。</p>
<p>&ensp;&ensp;&ensp;（1）对内核参数进行调优。</p>
<p>&ensp;&ensp;&ensp;（2）利用防火墙禁止掉部分IP。</p>
<p>&ensp;&ensp;&ensp;&ensp;Linux内核参数调优主要从下面几个方面进行：</p>
<p>&ensp;&ensp;&ensp;（1）限制SYN并发的数量，超时时间</p>
<p>&ensp;&ensp;&ensp;（2）增大tcp_max_syn_backblog</p>
<p>&ensp;&ensp;&ensp;&ensp;当半连接的请求数量超过了tcp_max_syn_backlog时，内核就会启用SYN cookie机制，不再把半连接请求放到队列里，而是用SYN cookie来检验。</p>
<p>&ensp;&ensp;&ensp;（3）减小tcp_synack_retries</p>
<p>&ensp;&ensp;&ensp;（4）启用tcp_syncookies</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;SYN cookie是非常巧妙地利用了TCP规范来绕过了TCP连接建立过程的验证过程，从而让服务器的负载可以大大降低在三次握手中，当服务器回应（SYN + ACK）包后，客户端要回应一个n + 1的ACK到服务器。其中n是服务器自己指定的。当启用tcp_syncookies时，backlog满了后，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列backlog里（即没有存储任何关于这个连接的信息，不浪费内存）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。</p>
<h2 id="tcp-粘包半包问题怎么处理？"><a href="#tcp-粘包半包问题怎么处理？" class="headerlink" title="tcp 粘包半包问题怎么处理？"></a>tcp 粘包半包问题怎么处理？</h2><p>粘包与分包的处理方法：</p>
<p>（1）一个是采用分隔符方式。在封装要传输的数据包的时候，采用的固定的符号作为结束符🔚。这样接收到的数据中，如果接收到数据后，出如果出现结尾标识，即进行人为的将粘包分开，如果一个包中没有我们定义的结尾标识符，则是人为出现了分包，则此时我们需要等待下一个数据包进行组包。如HTTP协议以\r\n结尾。</p>
<p>（2）在数据包中添加长度的方式。在数据包的头部或者某个固定的位置封装一个数据包的长度信息。当收到数据包之后，先解析长度然后按照长度截取数据包。</p>
<p>（3）</p>
<h2 id="域套接字比流式套接字快的原因"><a href="#域套接字比流式套接字快的原因" class="headerlink" title="域套接字比流式套接字快的原因"></a>域套接字比流式套接字快的原因</h2><p>域套接字用于同一台计算机上进程间的通信，</p>
<p>1、它仅仅只是复制数据.。</p>
<p>2、不执行协议的处理，不需要增加或删除网络报头。</p>
<p>3、不进行检验和的计算，也不产生序列号，不需要进行校验和的计算</p>
<p>4、无需发送确认报文</p>
<h2 id="tcp的socket怎么收取数据的，recv的返回值。"><a href="#tcp的socket怎么收取数据的，recv的返回值。" class="headerlink" title="tcp的socket怎么收取数据的，recv的返回值。"></a>tcp的socket怎么收取数据的，recv的返回值。</h2><p>TCP收取数据的时候，可以使用函数recv或者read对数据进行读取。</p>
<p>一般的返回值有：</p>
<p>ret  &gt; 0 成功从内核缓冲区读取到的数据大小</p>
<p>ret = 0 TCP连接已经关闭</p>
<p>ret=-1 错误，需要读取错误码进行判断</p>
<p>主要的错误码(errno)有：</p>
<p>EINTR：操作被信号中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cnt = (<span class="keyword">int</span>)recv(m_socket, pBuf,RECVSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>( cnt &gt;<span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正常处理数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">if</span>((cnt&lt;<span class="number">0</span>) &amp;&amp;(errno == EAGAIN||errno == EWOULDBLOCK||errno == EINTR)) </span><br><span class="line">         <span class="comment">//这几种错误码，认为连接是正常的，继续接收</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续接收数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//跳出接收循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TCP慢启动、拥塞控制、快重传、快恢复"><a href="#TCP慢启动、拥塞控制、快重传、快恢复" class="headerlink" title="TCP慢启动、拥塞控制、快重传、快恢复"></a>TCP慢启动、拥塞控制、快重传、快恢复</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>&ensp;&ensp;&ensp;&ensp;进程：进程是具有一定独立功能的程序关于某一个数据集合的一心运行活动，他是系统进程资源分配和调度的一个基本单位。<br>&ensp;&ensp;&ensp;&ensp;线程：线程是进程的一个实体，他是CPU分配和调度的基本单位。<br><strong>线程的优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;（1）易于调度。<br>&ensp;&ensp;&ensp;&ensp;（2）线程可以提供并发性，利用线程可以有效的实现并发。<br>&ensp;&ensp;&ensp;&ensp;（3）线程开销小。<br>&ensp;&ensp;&ensp;&ensp;（4）有利于发挥对处理器的优点。通过创建多线程，每个线程可以不同的处理器上运行，从而实现应用程序的并行，使得每个处理器都能得到充分发挥。<br><strong>进程与线程的区别</strong>：<br>&ensp;&ensp;&ensp;&ensp;&ensp;(1) 一个线程属于一个进程，而一个进程可以有多个线程。<br>&ensp;&ensp;&ensp;&ensp;（2）一个进程的所有线程共享一个进程的所有资源，这些资源包括有打开的文件，创建的socket，不同的进程是相互独立的<br>&ensp;&ensp;&ensp;&ensp;（3）线程是轻量级进程，进程有进程控制块，线程也有线程控制块。但是线程控制块比进程控制块小的很多，线程切换代价小，进程空间切换代价大，线程空间切换代价小。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p><strong>定义</strong>：<br>&ensp;&ensp;&ensp;&ensp;ps 命令观察进程的执行状态的时候，看到状态栏为defunct状态的进程，这些就是所谓的僵尸进程。<br><strong>僵尸进程的危害</strong><br>&ensp;&ensp;&ensp;&ensp;进程表中占用一个位置（slot）,由于进程表的容量是有限的，所以defunct进程不仅会占用系统资源，影响系统的性能，如果数目太多的话会导致系统的崩溃。<br><strong>僵尸进程产生的原因</strong><br>&ensp;&ensp;&ensp;&ensp;(1)操作系统对所有的进程维护一张进程表，每一个进程在进程表中都有一个entry（进入点），核心程序在执行该进程时候所使用的一切信息都是存储在entry（进入点）中，ps命令查看的就是这个进程表中的相关数据。<br>&ensp;&ensp;&ensp;&ensp;(2)当一个父进程fork()系统调用建立一个新的进程之后，核心进程就会在进程表中给子进程分配一个entry（进入点），然后将这些信息存放在对应的进程表内，这些信息中有一项就是其父进程的识别码。<br>&ensp;&ensp;&ensp;&ensp;(3)当子进程结束之后，其实该没有被真正的销毁，而此时进程表中的数据会被该进程的退出码（exit code），执行所需要的的CPU时间等等数据结构所取代，这些数据会一直保存到父进程读取为止。<br>&ensp;&ensp;&ensp;&ensp;（4）此时，该进程几乎已经放弃所有的把内存空间，没有任何可执行代码，同时也不能被调度，仅仅只是在进程表中保留一个位置，除此之外该进程不占用任何存储空间。该父进程一直没有注册SIGCHILD信号处理函数调用wait或者waitpid等待子进程结束，或者也没有注册忽略该信号，那么这些进程将会变成僵尸进程（zombie），如果父进程一直处于循环状态，系统中就会有很多的僵尸进程。<br><strong>解决的方法</strong><br>&ensp;&ensp;&ensp;&ensp;（1）重启服务器电脑，这个是最简单，最易用的方法，但是如果你服务器电脑上运行有其他的程序，那么这个方法，代价很大。<br>&ensp;&ensp;&ensp;&ensp;（2）找到僵尸进程的父进程，将父进程杀掉。ps -ef |grep defunct_process_id。<br><strong>如何防止僵尸进程</strong><br>&ensp;&ensp;&ensp;&ensp;（1）父进程fork之前注册之前忽略SIG_CLILD信号，忽略子进程退出相关的信息。调用函数：signal（SIGCHILD, SIG_IGN）。<br>&ensp;&ensp;&ensp;&ensp;（2）父进程调用wait,waitpid函数收集子进程退出的状态码。<br>&ensp;&ensp;&ensp;&ensp;（3）在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程，系统自动回收。<br>##死锁是怎么样产生的##<br><strong>死锁的定义</strong><br>&ensp;&ensp;&ensp;&ensp;系统中有若干个进程在并发运行，他们不断的申请和释放资源，在这一个过程中，由于争夺资源而处于无限期的等待资源的状态，此时导致程序无法继续进行，若无外力的作用，他都将无法推进下去，这是系统处于死锁状态，或者系统产生了死锁。<br><strong>产生死锁的原因</strong><br>&ensp;&ensp;&ensp;&ensp;（1）系统的资源不足，例如多个打印机，但是由于纸张不够，进程推进不下去，产生了死锁。<br>&ensp;&ensp;&ensp;&ensp;（2）进程推进顺序不对。<br>&ensp;&ensp;&ensp;&ensp;（3）资源的分配不当。<br><strong>产生死锁的条件</strong><br>&ensp;&ensp;&ensp;&ensp;（1）互斥性，每个资源每次只能被一个进程使用。<br>&ensp;&ensp;&ensp;&ensp;（2）请求与保持等待，当一个进程因为请求资源而被阻塞等待时，对已经获得的资源保持不释放。<br>&ensp;&ensp;&ensp;&ensp;（3）不可剥夺，进程已经获得资源，未使用完之前，不可被其他剥夺。<br>&ensp;&ensp;&ensp;&ensp;（4）环路等待，若干进程之间 形成首尾相接的的等待资源的关系。</p>
<h2 id="CPU的执行方式"><a href="#CPU的执行方式" class="headerlink" title="CPU的执行方式"></a>CPU的执行方式</h2><p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image3.jpg" alt="图来源于网络"><br>CPU的工作主要分为五个阶段：<br>1、取指令（IF，instruction fetch）。将一条程序执行指令从主存中取出来放到指令寄存器的一个过程。<br>2、指令译码阶段（ID，instruction decode）。取出指令之后，指令译码器按照预定的指令格式对取回的指令进行拆分和解释，识别区分不同的指令类别以及获取各种操作数的方法。<br>3、执行指令的阶段（EX，execute）。具体实现指令的功能，CPU的不同部分被连接起来，以执行所需的操作。<br>4、访问存取数的阶段（MEM，memory）。根据指令的需要访问主存，读取操作数，CPU得到操作数在主存的地址，并从主存中读取该操作数用于运算。<br>5、结果回写阶段（WB，write back）。作为最后一个阶段，结果写回阶段把指令的运行结果数据“写回”到某种存储形式。</p>
<p>资料参考<br><a href="https://www.jianshu.com/p/05c6c1d73144" target="_blank" rel="noopener">https://www.jianshu.com/p/05c6c1d73144</a><br><a href="https://www.jianshu.com/p/bfff5d0e718e" target="_blank" rel="noopener">https://www.jianshu.com/p/bfff5d0e718e</a></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>资料参考<br><a href="https://blog.csdn.net/Al_xin/article/details/38602093" target="_blank" rel="noopener">https://blog.csdn.net/Al_xin/article/details/38602093</a></p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/image4.jpg" alt="图来源于网络"><br>32位系统0-4G地址空间，用户空间内存，从低到高分别是五种不同的内存段。<br>1、只读段，主要包括有代码和一些常量。<br>2、数据段，主要包括全局变量。<br>3、堆，主要包括分配的内存，从低地址开始向上增长。<br>4、文件映射段，主要包括动态库、共享内存等，从高地址向下增长。<br>5、栈，包括局部变量，函数的调用的上下文等，栈的大小一般是固定的，一般是8M。<br>在这五个内存段中，堆和文件映射段是动态内存分配的，malloc或者mmap等。<br><strong>堆是线程私有还是共有？栈呢？</strong><br>1、在多线程环境下，每个线程拥有一个栈和一个程序计数器。<br>2、栈和程序计数器用来保存线程的执行历史和线程的执行状态，是线程私有的资源。<br>3、其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。</p>
<p>资料参考<br><a href="https://time.geekbang.org/column/article/74272" target="_blank" rel="noopener">https://time.geekbang.org/column/article/74272</a></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程，指的就是微线程。是应用层的一种概念。</p>
<p>&ensp;&ensp;&ensp;&ensp;协程最大的优势就是具有极高的执行效率。可以把协程看做是一种子程序，因为子程序的切换不是进程也不是线程的切换，因此没有进程或者线程的切换的开销。</p>
<h2 id="列出常见的信号，并解释下信号是怎么处理的。"><a href="#列出常见的信号，并解释下信号是怎么处理的。" class="headerlink" title="列出常见的信号，并解释下信号是怎么处理的。"></a>列出常见的信号，并解释下信号是怎么处理的。</h2><p>&ensp;&ensp;&ensp;&ensp;linux 系统下可以使用命令kill -l查看常见的信号。</p>
<p>&ensp;&ensp;&ensp;&ensp;信号实际上就是一种很短的信息，信号可以被发送到一个进程或者一组进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>不可靠信号：</strong>指的是非实时的信号📶，其中1~31信号就是不可靠信号。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可靠信号：</strong>指的是实时的信号，其中32~64信号是可靠信号📶。</p>
<p>&ensp;&ensp;&ensp;&ensp;可靠信号与不可靠信号的区别在于：不可靠信号不支持排队，可能会造成信号丢失，但是可靠信号不会。如果一个不可靠的信号📶被连续发送多次，那么只有其中的一个会被发送到接收进城。</p>
<p>&ensp;&ensp;&ensp;&ensp;内核给进程发送信号📶，实在进程所在的进程表项的信号阈设置相应的信号的位。</p>
<p>&ensp;&ensp;&ensp;&ensp;进程检查信号的时机是：进程即将从内核态返回用户态的时候。如果进程睡眠了，要看睡眠能不能被中断，如果能被中断则是进行唤醒。</p>
<h2 id="i-或者-i是否是原子操作，为什么。"><a href="#i-或者-i是否是原子操作，为什么。" class="headerlink" title="i++或者++i是否是原子操作，为什么。"></a>i++或者++i是否是原子操作，为什么。</h2><p>&ensp;&ensp;&ensp;&ensp;这个不是原子操作。因为i++这个可以在拆分为三个过程。</p>
<p>&ensp;&ensp;&ensp;&ensp;1、内存到寄存器</p>
<p>&ensp;&ensp;&ensp;&ensp;2、寄存器自增</p>
<p>&ensp;&ensp;&ensp;&ensp;3、写回内存。</p>
<p>&ensp;&ensp;&ensp;&ensp;这其中的任何一个阶段都有可能会被中断。</p>
<p>&ensp;&ensp;&ensp;&ensp;++i这个其实在多核处理器上，CPU在读取内存时候，也会可能发生同时读取到一个值，这样其实也会导致两次自增，实际上只是增加了一次。</p>
<p>&ensp;&ensp;&ensp;&ensp;所以，i++和++i都是不是原子操作。</p>
<h2 id="linux下的同步机制，以及死锁，如何避免死锁。"><a href="#linux下的同步机制，以及死锁，如何避免死锁。" class="headerlink" title="linux下的同步机制，以及死锁，如何避免死锁。"></a>linux下的同步机制，以及死锁，如何避免死锁。</h2><p>&ensp;&ensp;&ensp;&ensp;1、原子操作。原子操作不会被任何事物所打断，通常用于资源的计数，引用的计数。例如有TCP/IP协议栈的IP碎片计数。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、信号量。就像房间内有好几把钥匙🗝，拿到钥匙就去访问。设置为1的时候变为了mutex。绝大多数部分可以作为互斥锁来进行使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、读写信号量。可以允许多个读，一个写。一旦有人在写，就大家都不可以读取，如果没有在写，可以允许多个人进行读取。</p>
<p>&ensp;&ensp;&ensp;&ensp;4、锁🔐。自旋锁和互斥锁的区别在于是否会进行休眠。如果自旋锁被其他执行单元持有，那么调用者就会一直在那自旋，循环等待资源的释放。在持有时间很短的情况下一般使用自旋锁会比互斥锁稍微高效一些。</p>
<p><strong>死锁产生的必要条件：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1、资源一定是互斥的。</p>
<p>&ensp;&ensp;&ensp;&ensp;2、资源是不可抢占的。</p>
<p>&ensp;&ensp;&ensp;&ensp;3、占有且需要申请的。</p>
<p>&ensp;&ensp;&ensp;&ensp;4、需要循环等待的。</p>
<h2 id="exit和-exit-EXIT-的区别"><a href="#exit和-exit-EXIT-的区别" class="headerlink" title="exit和_exit(_EXIT)的区别"></a>exit和_exit(_EXIT)的区别</h2><p>&ensp;&ensp;&ensp;&ensp;_exit和_EXIT函数调用时候立即进入内核，exit函数则是会先进行一些清理处理，然后再返回内核。</p>
<p>&ensp;&ensp;&ensp;&ensp;exit函数总是会先执行一个标准的I/O库的清理关闭操作，对于所有打开流调用fclose函数，会将输出缓冲区中的所有数据都被冲洗。</p>
<p>&ensp;&ensp;&ensp;&ensp;_exit函数调用则是直接关闭文件📃，文件缓冲区中的内容也就直接消失了，这个时候是不会再输出到显示设备了。</p>
<h2 id="linux内存管理机制"><a href="#linux内存管理机制" class="headerlink" title="linux内存管理机制"></a>linux内存管理机制</h2><p>&ensp;&ensp;&ensp;&ensp;linux操作系统采用虚拟内存管理技术，将不同进程的虚拟地址空间和不同的内存物理地址映射起来，使得每个进程都有各自互不干扰的进程地址空间。</p>
<p>&ensp;&ensp;&ensp;&ensp;在32位的系统上该空间的大小为4G的现行虚拟空间，用户所看到的或者接触的都是虚拟地址空间，并不会看到实际的物理地址。操作系统引入了虚拟内存，那么进程持有的虚拟地址就会通过CPU的内存管理单元（MMU）的映射关系，转化成物理地址，然后再通过物理地址进程访问。只有那些实际使用的UNINEICUN才分配物理内存，并且分配之后的物理内存是通过内存映射来管理的。</p>
<p>&ensp;&ensp;&ensp;&ensp;内存映射，其实就是讲虚拟内存地址映射到物理内存地址，为了完成内存映射，内核为每一个进程都维护了一张页表，记录虚拟地址与物理地址之间的映射关系。页表实际上存储在CPU的内存管理单元MMU中，这样情况下，处理器可以直接通过硬件找出需要访问的内存。当进程访问虚拟地址在页表中查询不到的时候，系统就会产生一个缺页异常，进入到内核空间进行分配物理内存，更新进程页表，最后返回到用户空间，回复进程的运行。</p>
<p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/mmu.jpg" alt="图来源于网络"></p>
<p>&ensp;&ensp;&ensp;&ensp;MMU并不是以字节为单位来管理内存的，而是规定了一乐内存映射的最小单位，页。通常是4KB大小，这样每一个内存映射，都需要关联4KB或者4KB的整数倍的内存空间。</p>
<p><strong>多级页表</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;多级页表就是把内存分成区块来进行管理，将原来的映射关系改成区块索引和区块偏移。由于虚拟地址空间通常只用很少的一部分，那么多级页表就只保存这些使用的区块，这样就可以大大的减少页表的项数。</p>
<p>Linux是用过四级页表来管理内存的，如下图。虚拟地址被分为5个部分，前四个表项用于选择页，而最后一个表项这是索引表示页内偏移。</p>
<p><img src="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/ye_biao.jpg" alt="图片来源于网络"></p>
<p>再看大页，大页指的是比普通页更大的内存块，常见的大小有2MB和1GB。大页通常用在使用大量内存的进程上，比如Oracle、DPDK等。</p>
<p><strong>内存的分配与回收♻️</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;在C标准库中，malloc是其提供的内存分配函数，对应的系统调用上主要有两种实现的方式，即brk()和mmap()。</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）对于小块的内存，C标准库使用brk()来进行分配，也就是通过移动堆顶的位置来进行分配内存，这些内存释放之后不会立刻归还给系统，而是会被缓存起来，这样可以重复使用。</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）对于大块的内存（大于128K），则是使用内内存映射mmap()来进行分配，也就是在文件映射段找到一块空闲的内内存分配出去。</p>
<p>这两种方式的优缺点：</p>
<p>&ensp;&ensp;&ensp;&ensp;brk()方式的缓存，可以减少却也一行的发生，可以提高内存的访问效率，不过，由于这些内存没有归还给系统，在内存繁忙的时候，频繁的内存分配和释放会造成内存碎片。</p>
<p>&ensp;&ensp;&ensp;&ensp;mmap（）方式的分配内存，会在释放时候直接归还给系统，所以每次mmap都会发生缺页异常。在内存工作繁忙的时候，频繁的内存分配会导致大量的缺页异常的发生，使得内存的管理负担增大，这也是malloc只对大块内存使用mmap的原因。</p>
<p>&ensp;&ensp;&ensp;&ensp;了解了这两种，调用方式之后，我们还需要清楚的了解一点，就是当发生这两种调用方式之后，其实没有镇长的分配内存，这些实际使用的内存，只有在首次访问的时候才进行分配，也就是通过缺页异常进入到内核中，再由内核进行分配内存。</p>
<h2 id="Linux的任务调度机制"><a href="#Linux的任务调度机制" class="headerlink" title="Linux的任务调度机制"></a>Linux的任务调度机制</h2><p>&ensp;&ensp;&ensp;&ensp;&ensp;Linux作为一个多任务的操作系统，必须支持程序的并发执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;多任务一般分为两类，非抢占式多任务与抢占式多任务。</p>
<p><strong>&ensp;&ensp;&ensp;&ensp;&ensp;非抢占式多任务：</strong>除非任务自己结束🔚，否则将会一直执行。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>抢占式多任务：</strong>这种情况下，由调度程序来决定什么时候停止一个进程的运行，这个强制的挂起动作则是<strong>抢占</strong>。抢占式多任务的基础就是使用<strong>时间片轮转</strong>机制来为每一个进程分配可以运行的时间单位。</p>
<p><strong>策略：</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>I/O消耗性和CPU消耗形。</strong>为了保证交互式桌面系统的性能，linux一般更倾向于优先调度I/O消耗形的进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;<strong>进程优先级。</strong>Linux采用两种不同的优先级范围。</p>
<p>&ensp;&ensp;&ensp;&ensp;（1）使用nice值：越大的nice值意味着更低的优先级。（-19~20之间）</p>
<p>&ensp;&ensp;&ensp;&ensp;（2）实时优先级：可以配置，越高表示进程的优先级越高。</p>
<h2 id="标准库函数和系统调用的区别"><a href="#标准库函数和系统调用的区别" class="headerlink" title="标准库函数和系统调用的区别"></a>标准库函数和系统调用的区别</h2><p>&ensp;&ensp;&ensp;&ensp;标准库函数，是语言本身的一部分，系统函数则是内核提供给应用层程序的一个接口，属于系统的一部分。函数库调用是语言或者应用程序的一部分，而系统调用则是操作系统的一部分。</p>
<p>&ensp;&ensp;&ensp;&ensp;系统调用通常用于<strong>底层文件访问（low-level file access）</strong>，例如在驱动程序中对设备文件的直接访问。</p>
<p>&ensp;&ensp;&ensp;&ensp;系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。</p>
<h2 id="如何查看进程打开的文件"><a href="#如何查看进程打开的文件" class="headerlink" title="如何查看进程打开的文件"></a>如何查看进程打开的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、查看谁正在使用某个文件</span><br><span class="line">lsof /filepath/file</span><br><span class="line"></span><br><span class="line">2、通过某个进程号显示该进行打开的文件</span><br><span class="line">lsof -p 1</span><br></pre></td></tr></table></figure>

<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//blog.csdn.net/zhangye3017/article/details/80382496</span></span><br></pre></td></tr></table></figure>



<h1 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h1><h2 id="memcpy比较两个结构体"><a href="#memcpy比较两个结构体" class="headerlink" title="memcpy比较两个结构体"></a>memcpy比较两个结构体</h2><p>不能。结构体struct 对象由于内存对齐会有内存间隙，就算其中的成员变量相等，内存直接比较还是不能相等。</p>
<p>1、结构体赋值之前可以初始化memset一下，然后可以用memcpy来进行对比，（如果有指针的话 不行）</p>
<p>2、可以使用运算符重载进行成员一一比较，看看变量是否相等。</p>
<p>每个<strong>特定平台</strong>上的编译器都有自己的默认“<strong>对齐系数</strong>”。可以通过预编译命令#pragma pack(n)</p>
<p>在经过对齐原则分析后，检查计算出的存储单元是否为所有元素中所占内存最大的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。</p>
<h2 id="strcpy与memcpy的区别"><a href="#strcpy与memcpy的区别" class="headerlink" title="strcpy与memcpy的区别"></a>strcpy与memcpy的区别</h2><p>1、一个是字符串拷贝函数一个是内存拷贝函数</p>
<p>2、strcpy无需制定长度，遇到’\0’结束，无法复制0值</p>
<p>3、memcpy是内存拷贝函数，将制定长度的字节直接整个拷贝不进行内容检查。</p>
<p>4、strcpy是不安全字符串操作函数，如果参数dest所指定的内存空间不够大，那么久会出现缓冲区溢出问题，严重的话会导致程序崩溃。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><strong>Redis内存数据库的内存指的是共享内存么</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;Redis 是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说 Redis 是实现网站高并发不可或缺的一部分，并不是指在一定只是在共享内存存取数据。</p>
<h2 id="redis持久化方式"><a href="#redis持久化方式" class="headerlink" title="redis持久化方式"></a>redis持久化方式</h2><p>Redis的持久化方式主要有两种RDB和AOF两种。<br>&ensp;&ensp;&ensp;&ensp;RDB持久化是在一定的时间间隔内生成内存数据集的时间点的一个快照。<br>&ensp;&ensp;&ensp;&ensp;AOF持久化则是记录服务器执行的所有写操作命令，并且在服务器启动的时候，通过执行这些命令来对数据进行还原。<br><strong>RDB的优点</strong><br>&ensp;&ensp;&ensp;&ensp;1、采用RDB方式持久化，整个redis数据库将会只包含一个文件，对于这个备份文件来说很完美的。一旦系统出现故障，我们可以很快的进行恢复。<br>&ensp;&ensp;&ensp;&ensp;2、对于灾难恢复，RDB是一个不错的选择，可以压缩成 其他格式进行存储。<br>&ensp;&ensp;&ensp;&ensp;3、能使性能最大化。在进行持久化之时候，只需要fork一个子进程进行持久化工作，这样服务进程就能极大的避免进行IO操作。<br>&ensp;&ensp;&ensp;&ensp;4、相对于AOF而言，如果数据库的数据集很大的话，RDB的启动效率会高一些。<br><strong>RDB的缺点</strong><br>主要有两点：<br>&ensp;&ensp;&ensp;&ensp;1、在持久化任务进行之前，如果系统出现宕机，那么此前还没有进行持久化写入磁盘的数据将会丢失，对于数据的高可用性、完整性要求比较高的场景这种持久化的方式将不会是一个很好的选择。<br>&ensp;&ensp;&ensp;&ensp;2、因为RDB是通过fork子进程来进行协助完成持久化，如果数据集特别大的话，可能这个时候服务器会停止服务几百毫秒甚至一秒。<br><strong>AOF的优点</strong><br>&ensp;&ensp;&ensp;&ensp;1、相比于RDB有更好的数据安全性和数据持久性。在redis中主要提供了三种同步策略，每秒同步，每修改同步，还有不同同步。<br>&ensp;&ensp;&ensp;&ensp;2、由于这个机制对日志文件的写入操作是以append追加的方式进行。所以即使系统宕机了也不会破坏日志文件中已经存在的内容。<br>&ensp;&ensp;&ensp;&ensp;3、AOF日志文件中包含了对数据库的所有修改操作，我们可以通过该日志文件完成数据的重建。<br><strong>AOF的缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1、对于相同的数据集而言，AOF文件通常大于RDB文件，在进行数据恢复的时候速通常比RDB慢。<br>&ensp;&ensp;&ensp;&ensp;2、根据同步的策略，AOF在运行效率上往往会慢于RDB。</p>
<h2 id="持久化方式的选择"><a href="#持久化方式的选择" class="headerlink" title="持久化方式的选择"></a>持久化方式的选择</h2><p>&ensp;&ensp;&ensp;&ensp;1、对于数据一致性要求比较高的场景，建议使用使用AOF。<br>&ensp;&ensp;&ensp;&ensp;2、对于数据丢失的一部分没有那么看重的话，建议选择RDB。<br>&ensp;&ensp;&ensp;&ensp;3、如果对于数据的一致性、完整性特别重视，建议两种都开启。<br>&ensp;&ensp;&ensp;&ensp;4、AOF方式在不开启fsync的时候，性能和RDB相当。建议开启AOF方式的每秒钟同步一次。</p>
<h2 id="redis和mysql有什么区别，用于什么场景"><a href="#redis和mysql有什么区别，用于什么场景" class="headerlink" title="redis和mysql有什么区别，用于什么场景"></a>redis和mysql有什么区别，用于什么场景</h2><p>&ensp;&ensp;&ensp;&ensp;1、redis 基于内存，读写速度快，可以持久化但是内存空间有限，数据量超过内存空间时，需要进行扩充内存。<br>&ensp;&ensp;&ensp;&ensp;2、MySQL则是磁盘存储，读写相对于redis扫稍慢些，但是不受空间容量限制，性价比高。</p>
<p>&ensp;&ensp;&ensp;&ensp;在大多数的场景下都是MySQL+Redis配合使用，MySQL作为主存储库，Redis用作缓存可以加快访问速度。在需要高性能的地方使用Redis在不需要的高性能的地方使用MySQL。存储数据在MySQL和Redis之间做同步。</p>
<p>&ensp;&ensp;&ensp;&ensp;使用Redis缓存到MySQL。可以把表中经常访问的数据记录在Redis中，在需要查询数据的时候，先去Redis查询，如果查询不到再去MySQL中进行查找，这样可以实现读写分离。现在的软件大量的软件使用Redis作为MySQL在本地的缓存数据库，再适当的时候和MySQL同步。</p>
<h2 id="Redis缓存更新的模式以及出现的问题和应对思路"><a href="#Redis缓存更新的模式以及出现的问题和应对思路" class="headerlink" title="Redis缓存更新的模式以及出现的问题和应对思路"></a>Redis缓存更新的模式以及出现的问题和应对思路</h2><p>首先了解三个概念。<br>&ensp;&ensp;&ensp;&ensp;1、缓存雪崩<br>&ensp;&ensp;&ensp;&ensp;2、缓存穿透<br>&ensp;&ensp;&ensp;&ensp;3、缓存击穿<br><strong>缓存雪崩</strong><br>&ensp;&ensp;&ensp;&ensp;目前电商的首页以及热点的数据都会去做缓存，一般的缓存都是定时任务去更新或者说是查不到数据之后去数据库更新，在这里定时更新就会可能出现问题。缓存雪崩就是同一时间内大量的key值失效的瞬间或者同一瞬间大面积的请求数据库。这一瞬间，Redis缓存和没有一样，这个时候这个数量级别的请求直接打在数据库上几乎就是灾难性的。这就是缓存雪崩。</p>
<p>应对思路：在批量往Redis存储数据的时候，需要把每个key的失效时间都加个随机值就好了，这样可以保证同一时间大面积失效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis(key, values, time+Math.random()*<span class="number">10000</span>)</span><br></pre></td></tr></table></figure>

<p><strong>缓存穿透</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓存穿透，指的是缓存和数据库中都没有请求的数据，而且用户却不断发起请求，导致数据库压力大，严重时候会直接击垮数据库。</p>
<p>应对思路：接口层做参数校验，比如用户授权检验，参数做校验，对于不符合的数据直接return返回。对于Java来说，还有个高级的用法采用<strong><em>布隆过滤器（Bloom Filter）</em></strong>这个也可以很好的防止缓存穿透的发生，他的原理就是利用高效的数据结构和算法快速判断这个key在数据库中是否存在。</p>
<p><strong>缓存击穿</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;缓存击穿和和缓存雪崩有点类似，但是两者有点区别。雪崩是因为大面积缓存失效，打崩数据库。缓存击穿则是指的是一个key非常热点，在不停的扛着大并发，大并发集中对一个点进行访问，当这个key在失效的瞬间，持续的大并发就会击穿缓存，直接请求数据库，就像在一个完好无损的桶上开了一个洞。</p>
<p>应对思路：设置热点数据永不过期，或者加上互斥锁🔐就可以解决这个问题。</p>
<h2 id="Redis的hash是什么实现的"><a href="#Redis的hash是什么实现的" class="headerlink" title="Redis的hash是什么实现的"></a>Redis的hash是什么实现的</h2><p>&ensp;&ensp;&ensp;&ensp;Redis中的字典采用哈希表作为底层实现，一个哈希表多个节点，每个节点保存一个键值对。Redis数据库就是使用字典作为底层实现的，通过key和value的键值对形式，代表了数据库中的全部数据。而且对数据库的增删改查都是建立在对字典的操作上。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、<a href="https://blog.csdn.net/xp731574722/article/details/82868560" target="_blank" rel="noopener">https://blog.csdn.net/xp731574722/article/details/82868560</a></p>
<p>2、<a href="https://blog.csdn.net/kozazyh/article/details/5495532" target="_blank" rel="noopener">https://blog.csdn.net/kozazyh/article/details/5495532</a></p>
<p>3、<a href="https://blog.csdn.net/zhangye3017/article/details/80382496" target="_blank" rel="noopener">https://blog.csdn.net/zhangye3017/article/details/80382496</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/03/13/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/" data-id="cklan5l7x001b180rdq3dc6o1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-链表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2020-03-03T17:12:56.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/04/%E9%93%BE%E8%A1%A8/">链表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<h1 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h1><p>&ensp;&ensp;&ensp;&ensp;链表是一组数据项的集合，其中每一个数据项都是一个节点的一部分，每一个节点都包含有指向下一个节点的链接。</p>
<h1 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h1><p>（1）<strong>逻辑结构</strong>。数组需要实现定义固定长度（元素个数），不能适应动态的增加或者删除数据元素。<br>（2）<strong>内存结构</strong>。（静态）数组从占空间分配内存，快捷方便，但是自由度小。链表从堆中进行分配，自由度大。<br>（3）<strong>存储结构</strong>。数组在内存中是顺序存储，而链表是随机存储。数组的访问效率很高，但是插入和删除效率低，链表相反。<br>（4）数组会存在越界的问题，但是链表不会。</p>
<h1 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h1><h2 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h2><p>&ensp;&ensp;&ensp;&ensp;缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU缓存、数据库缓存、浏览器缓存等等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：<strong>先进先出策略</strong> FIFO（First In，First Out）、<strong>最少使用策略</strong> LFU（Least Frequently Used）、<strong>最近最少使用策略</strong> LRU（Least Recently Used）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#define ture 1</span><br><span class="line">#define false 0</span><br><span class="line"></span><br><span class="line">typedef int Data_type;</span><br><span class="line">typedef struct _Node&#123;</span><br><span class="line">	Data_type data;</span><br><span class="line">	struct _Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line">&#x2F;* 将数据插入到头部 *&#x2F;</span><br><span class="line">void intsert_elem_to_begin(Data_type data);</span><br><span class="line"></span><br><span class="line">&#x2F;* 查找元素，存在则是返回1，不存在返回0 *&#x2F;</span><br><span class="line">int find_elem(Data_type data);</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除链表尾部结点 *&#x2F;</span><br><span class="line">void dalete_tail_elem();</span><br><span class="line"></span><br><span class="line">&#x2F;* 删除指定元素结点 *&#x2F;</span><br><span class="line">int delete_elem(Data_type data);</span><br><span class="line"></span><br><span class="line">&#x2F;* 判断链表是否满 *&#x2F;</span><br><span class="line">int is_full();</span><br><span class="line"></span><br><span class="line">&#x2F;* 判断链表是否为空 *&#x2F;</span><br><span class="line">int is_empty();</span><br><span class="line"></span><br><span class="line">&#x2F;* 打印所有数据 *&#x2F;</span><br><span class="line">void show_all();</span><br></pre></td></tr></table></figure>
<hr>
<p>感谢您花费时间阅读这篇文章，书中有错误的地方或者有什么建议都可以留言，或者通过邮件祝您在这里记录、阅读、分享愉快！</p>
<p>作&ensp;者:&ensp;lpyuan<br>Email:&ensp;<a href="mailto:lpyuan21@outlook.com">lpyuan21@outlook.com</a><br>2020年02月28日 02:52:00   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/03/04/%E9%93%BE%E8%A1%A8/" data-id="cklan5l7t0018180r4ubz94o5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Centos-hexo搭建个人网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/" class="article-date">
  <time datetime="2020-03-01T09:29:07.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/">Centos+hexo搭建个人网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p>&ensp;&ensp;&ensp;&ensp;花了好几天，熬了几个夜晚，终于把自己的个人博客搭建起来了网站，顺便来一篇教程，分享给大家，同时也方便以后再次部署。我之前是在github上搭建了一版，github+hexo,奈何实在太卡了，想起自己在阿里云有台服务器，然后直接部署到云上了,下面方法步骤亲测成功。</p>
<h1 id="需要准备的东西"><a href="#需要准备的东西" class="headerlink" title="需要准备的东西"></a>需要准备的东西</h1><blockquote>
<ul>
<li>一台个人PC</li>
<li>money!(开玩笑的 ^-^)</li>
<li>一台linux服务器，可以买台云服务器，没有又想体验的话就VM虚拟机，本地看看过把瘾吧。^ ^</li>
</ul>
</blockquote>
<h1 id="需要的软件环境"><a href="#需要的软件环境" class="headerlink" title="需要的软件环境"></a>需要的软件环境</h1><blockquote>
<ul>
<li>Git</li>
<li>Node.js</li>
<li>hexo-cli</li>
<li>Nginx</li>
</ul>
</blockquote>
<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a><br>下一步下一步傻瓜式安装</p>
<h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a><br>下一步下一步傻瓜式安装</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p><img src="/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/image1.jpg" alt="点击图片时候下方显示描述"></p>
<p>&ensp;&ensp;&ensp;&ensp;选择一个文件夹作为你的博客文件夹，比如我自己建立在E:盘在命令行窗口下：</p>
<p><img src="/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/image2.jpg" alt="点击图片时候下方显示描述"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hexo -v     # 查看hexo安装成功没</span><br><span class="line">cd e:       # 打开e盘;</span><br><span class="line">mkdir blog; # 创建blog文件夹作为我的博客目录</span><br><span class="line">cd blog     # 进入blog目录</span><br><span class="line">hexo init   # 初始化blog</span><br><span class="line">hexo g      # 生成静态页面</span><br><span class="line">hexo s      # 启动服务监听</span><br><span class="line">打开页面    localhost:4000</span><br><span class="line">可以看到hello world 的页面，初步完成。</span><br><span class="line"></span><br><span class="line">常用命令</span><br><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line"></span><br><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/03/01/Centos-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/" data-id="cklan5l6u0000180rer8ta3fq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Google浏览器无法安装问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-01T09:03:02.000Z" itemprop="datePublished">2020-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/windows/">windows</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/">Google浏览器无法安装问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/image1.jpg" alt="点击图片时候下方显示描述"></p>
<p>&ensp;&ensp;&ensp;&ensp;今天遇到一个有趣的问题，Google浏览器莫名其面的一直安装不上，自己捣鼓了好久最后才解决。网上有很多方法说是因为注册表有残留，准确的说是GoogleUpdate这个东西在作怪，解决的方法只需要将注册表里Google相关的东西删除。</p>
<h1 id="1、打开注册表直接Win-R输入regedit"><a href="#1、打开注册表直接Win-R输入regedit" class="headerlink" title="1、打开注册表直接Win+R输入regedit"></a>1、打开注册表直接Win+R输入regedit</h1><p><img src="/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/image2.jpg" alt></p>
<h1 id="2、删除注册表残留数据。"><a href="#2、删除注册表残留数据。" class="headerlink" title="2、删除注册表残留数据。"></a>2、删除注册表残留数据。</h1><p>&ensp;&ensp;&ensp;&ensp;删除\HKEY_CURRENT_USER\Software\和HKEY_LOCAL_MACHINE\SOFTWARE目录下的Google及对应的子目录就可以了。但是我操作的时候出现了问题，删除Google目录时候报错，后面发现是权限问题。解决方法：右键该目录修改管理员权限可以删除。</p>
<h1 id="3、确认电脑系统版本。"><a href="#3、确认电脑系统版本。" class="headerlink" title="3、确认电脑系统版本。"></a>3、确认电脑系统版本。</h1><p>&ensp;&ensp;&ensp;&ensp;可以删除之后还是发现无法安装，最后发现照着网上的帖子没有用，因为帖子估计都比较老，我的是win10系统，所以导致删除的路径不对，导致依旧无法正常安装，需要删除对应的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32位：HKEY_LOCAL_MACHINE\SOFTWARE\Google</span><br><span class="line">64位：HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Google</span><br></pre></td></tr></table></figure>
<h1 id="4、重启安装应用。"><a href="#4、重启安装应用。" class="headerlink" title="4、重启安装应用。"></a>4、重启安装应用。</h1><p>&ensp;&ensp;&ensp;&ensp;重新双击运行安装应用程序，完美解决！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/03/01/Google%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/" data-id="cklan5l6z0001180r0z964gno" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows/">windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/18/Linux%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84EAGIN%E5%BC%82%E5%B8%B8/">Linux非阻塞模式下的EAGIN异常</a>
          </li>
        
          <li>
            <a href="/2021/01/07/Raft%E7%AE%97%E6%B3%95/">Raft算法</a>
          </li>
        
          <li>
            <a href="/2021/01/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
          </li>
        
          <li>
            <a href="/2021/01/07/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/">海量数据处理问题</a>
          </li>
        
          <li>
            <a href="/2021/01/06/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 发量充足的程序员<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>