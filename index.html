<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Suzette219</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Suzette219">
<meta property="og:url" content="http://www.lpyuan.club/index.html">
<meta property="og:site_name" content="Suzette219">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="发量充足的程序员">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Suzette219" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Suzette219</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.lpyuan.club"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux非阻塞模式下的EAGIN异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/18/Linux%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84EAGIN%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2021-02-18T08:39:14.000Z" itemprop="datePublished">2021-02-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/18/Linux%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84EAGIN%E5%BC%82%E5%B8%B8/">Linux非阻塞模式下的EAGIN异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Linux非阻塞模式下的EAGIN异常"><a href="#Linux非阻塞模式下的EAGIN异常" class="headerlink" title="Linux非阻塞模式下的EAGIN异常"></a>Linux非阻塞模式下的EAGIN异常</h1><p>之前在写一个并发聊天室时候在多个客户端连续发送数据的时候遇到EAGIN错误，如图。</p>
<p>![image-20210218161957083](/Users/xiaoluo/Library/Application Support/typora-user-images/image-20210218161957083.png)</p>
<p>Linux下，管道、FIFO以及一些设备（通常是终端和网络）一般有以下几种性质。</p>
<blockquote>
<p>1、一次read操作返回的数据可能会少于所要求的数据，及时此时没有到达文件尾部也可能会出现这种情况。对于这种情况，我们不认为是错误，而是视为一种异常，应该继续对此设备进行读取。</p>
<p>2、一次write或send操作的返回值也可能会少于指定的输出的字节数。通常这可能是由于某一种因素引起的，比如在处理网络数据的时，内核输出的缓冲区满，此时写不进数据。我们也通常不认为这是一种错误，应当继续将余下的数据进行写入。（通常遇到这种情况的场景是非阻塞描述符，或者捕捉到某一种信号的时候，才会发生中途返回。）</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/02/18/Linux%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84EAGIN%E5%BC%82%E5%B8%B8/" data-id="cklan55j00002z20rdbxbhcp2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Raft算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/07/Raft%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-01-06T19:58:59.000Z" itemprop="datePublished">2021-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/07/Raft%E7%AE%97%E6%B3%95/">Raft算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><h2 id="什么是Raft算法"><a href="#什么是Raft算法" class="headerlink" title="什么是Raft算法"></a>什么是Raft算法</h2><p>Raft算法是Multi-Paxos算法，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/01/07/Raft%E7%AE%97%E6%B3%95/" data-id="cklan55j8000cz20rfiq045f4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-01-06T19:40:19.000Z" itemprop="datePublished">2021-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>十大经典排序算法为：冒泡，选择，插入、希尔、归并、快速、堆、计数、桶、基数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int a[] &#x3D; &#123;5,4,9,8,7,6,0,1,3,2&#125;;</span><br><span class="line">    prin_array(a, sizeof(a)&#x2F;sizeof(a[0])); </span><br><span class="line">    int len &#x3D; sizeof(a)&#x2F;sizeof(a[0]);</span><br><span class="line">    &#x2F;&#x2F; BubbleSort(a, sizeof(a)&#x2F;sizeof(a[0]));</span><br><span class="line">    SelectSort(a, sizeof(a)&#x2F;sizeof(a[0]));</span><br><span class="line">    prin_array(a, sizeof(a)&#x2F;sizeof(a[0]));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>1、比较相邻的两个元素，如果第一个比第二个大，就交换他们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void BubbleSort(int array[], int len)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j &#x3D; 0; j &lt; len-1-i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (array[j] &gt; array[j+1])</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(&amp;array[j], &amp;array[j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SelectSort(int array[], int len)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int min, index;</span><br><span class="line">    for ( i &#x3D; 0; i &lt; len-1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min &#x3D; array[i];</span><br><span class="line">        &#x2F;* code *&#x2F;</span><br><span class="line">        for ( j &#x3D; i+1; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (min &gt; array[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min &#x3D; array[j];</span><br><span class="line">                index &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Swap(&amp;array[i], &amp;array[index]);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void InsertSort(int array[], int len)&#123;</span><br><span class="line"></span><br><span class="line">    int i, j;</span><br><span class="line">    int temp;</span><br><span class="line">    for ( i &#x3D; 1; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp &#x3D; array[i];</span><br><span class="line">        for ( j &#x3D; i-1; j &gt;&#x3D;0; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;* code *&#x2F;</span><br><span class="line">            if (temp &lt; array[j])&#123;</span><br><span class="line">                array[j+1] &#x3D; array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        array[j+1] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/01/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cklan55je000nz20r6c0t77ox" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-海量数据处理问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/07/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2021-01-06T19:37:46.000Z" itemprop="datePublished">2021-01-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/07/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/">海量数据处理问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-海量数据问题"><a href="#1-海量数据问题" class="headerlink" title="1 海量数据问题"></a>1 海量数据问题</h2><h3 id="1-1-海量日志数据，提取出某日访问百度次数最多的那个IP。"><a href="#1-1-海量日志数据，提取出某日访问百度次数最多的那个IP。" class="headerlink" title="1.1 海量日志数据，提取出某日访问百度次数最多的那个IP。"></a>1.1 海量日志数据，提取出某日访问百度次数最多的那个IP。</h3><p>首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。</p>
<p>算法思想：分而治之+哈希</p>
<p>1、IP地址最多有2^32=4G种取值情况，所以不能一次性直接都完全加载到内存中。</p>
<p>2、考虑分而治之的思想，将IP地址进行hash(IP)%1024，把海量的数据分别存储到1024个文件中，这样，每个文件最有就含有4MB个IP地址。</p>
<p>3、对于每一个小文件，可以进行构造一个key value的hash map，将IP作为key值，出现的次数作为value值，同时记录下当前出现次数最多的那个IP地址。</p>
<p>4、可以得到1024个文件📃中出现次数最多的IP，再根据常规的排序算法得到总体上的出现次数最多的IP。</p>
<h3 id="1-2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节"><a href="#1-2-搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节" class="headerlink" title="1.2 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节"></a>1.2 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节</h3><p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p>
<p>算法思想：经典的topK问题。</p>
<p>1、先对这批海量数据进行预处理，在O(n)的时间之内用hash表完成统计。</p>
<p>2、借助堆这个数据结构，找出topk，时间复杂度为nlogK。借助堆这个数据结构，我们可以在log量级的时间内查找和调整移动。我们可以维护一个大顶堆，然后遍历这300万左右的数据，分别和根元素进行比对，最后得出前十个热门的查询串。</p>
<h3 id="1-3-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词"><a href="#1-3-有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词" class="headerlink" title="1.3 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词"></a>1.3 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词</h3><p>算法思想：分而治之+hash</p>
<p>1、顺序读取文件，对于读取的每一个值，可以使用hash(x)%5000，将读取的词存储到5000个文件中，每个文件大概200k，如果还是有文件大于1m，可以按照这个方法继续往下分，直到可以直接放入内存中为止。</p>
<p>2、对于每一个小文件，统计每个文件节点中出现的词以及相应的一个频率（tries树🌲或者hashMap都可以）。取出出现频率最大的一百个词（可以采用含有100个节点的最小堆），这样又可以得到5000个文件。最后一步，可以将这5000个文件进行归并过程了（类似于归并排序）。</p>
<h3 id="1-4-在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。"><a href="#1-4-在2-5亿个整数中找出不重复的整数，内存不足以容纳这2-5亿个整数。" class="headerlink" title="1.4 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。"></a>1.4 在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。</h3><p>方案1：可以采用2-bitmap进行，共需要内存</p>
<h3 id="1-5-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"><a href="#1-5-海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。" class="headerlink" title="1.5 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。"></a>1.5 海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。</h3><h3 id="1-6-腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"><a href="#1-6-腾讯面试题：给40亿个不重复的unsigned-int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？" class="headerlink" title="1.6 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？"></a>1.6 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</h3><p>使用bitmap，或者布隆过滤器。</p>
<h3 id="1-7-10亿个域名如何判断，新来一个域名，如何判断在还是不在"><a href="#1-7-10亿个域名如何判断，新来一个域名，如何判断在还是不在" class="headerlink" title="1.7 10亿个域名如何判断，新来一个域名，如何判断在还是不在"></a>1.7 10亿个域名如何判断，新来一个域名，如何判断在还是不在</h3><p>可以使用布隆过滤器，判断不在就一定不在，判断在的话可能不在。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/01/07/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/" data-id="cklan55jg000qz20r3mqzdria" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-结构体对齐" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/06/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/" class="article-date">
  <time datetime="2021-01-05T22:21:28.000Z" itemprop="datePublished">2021-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/06/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>结构体对齐一直是一个老生常谈的问题，我面试过就被问过几次，但是每一次都复习准备好好的，但是一到面试时候，总能被面试官问倒（卑微~）其实主要的原因就是自己没有准确的深刻的理解结构体对齐这个知识点，没有对其进行一个总结。</p>
</blockquote>
<h2 id="为什么需要结构体对齐"><a href="#为什么需要结构体对齐" class="headerlink" title="为什么需要结构体对齐"></a>为什么需要结构体对齐</h2><p>结构体需要对其的原因主要就是对CPU对内存访问效率优化的一个问题。假设是intel 32的CPU， 每个总线周期都是要从偶地址读取32位的内存数据。</p>
<p>假设我们的CPU和总线都是64位的，每次可以从内存中获取8个字节（Byte）64位（bit）的数据，这8个字节就是对齐的，假设就是0<del>7，8</del>15类似这样，你不能从中间3<del>10这样取值。如果需要取值3</del>10之间的数据，就需要取两次，分别是0<del>7，再取8</del>15。所以CPU的取值效率就下降了。</p>
<h2 id="对齐的几个基本的原则"><a href="#对齐的几个基本的原则" class="headerlink" title="对齐的几个基本的原则"></a>对齐的几个基本的原则</h2><p>1、结构体变量的起始地址能够被其最宽的成员大小整除。</p>
<p>2、结构体每个成员相对于起始地址的偏移能够被自身大小整除，如果不能则在前一个成员后面补充字节。</p>
<p>3、结构体总的大小能够被最宽的成员大小整除，如果不能则是在后面进行一个补齐。</p>
<p>结构体其实也是可以指定编译器对齐大小的，例如以下的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>  b;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br></pre></td></tr></table></figure>

<p>sizeof(a)的大小为5。</p>
<h2 id="几种变形情况"><a href="#几种变形情况" class="headerlink" title="几种变形情况"></a>几种变形情况</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">int</span>  b;</span><br><span class="line">	short c;</span><br><span class="line">&#125;A1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量a，自身按1字节对齐，</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.zhihu.com/question/27862634" target="_blank" rel="noopener">https://www.zhihu.com/question/27862634</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1055149?from=information.detail.linux%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1055149?from=information.detail.linux%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/01/06/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/" data-id="cklan55jj000xz20r5wj8c68g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-进程间通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/04/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="article-date">
  <time datetime="2021-01-03T23:34:54.000Z" itemprop="datePublished">2021-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/04/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>原子操作</strong>，即不可分割开的操作；该操作一定是在同一个cpu时间片中完成，这样即使线程被切换，多个线程也不会看到同一块内存中不完整的数据。</p>
<p>线程同步的主要方式–线程锁 线程同步最常用的方法是使用<strong>锁</strong>(Lock)。锁是一种非强制机制，每一个线程访问数据或资源之前，首先试图获取(Acquireuytreewq)锁,并在访问结束之后释放(release)。在锁已经被占用时获取锁，线程会等待，直到该锁被释放。</p>
<p><strong>互斥锁</strong> 是在很多平台上都比较常用的一种锁。它属于sleep-waiting类型的锁。即当锁处于占用状态时，其他线程会挂起，当锁被释放时，所有等待的线程都将被唤醒，再次对锁进行竞争。在挂起与释放过程中，涉及用户态与内核态之间的context切换，而这种切换是比较消耗性能的。</p>
<p><strong>自旋锁</strong> 与互斥锁有点类似，只是自旋锁被某线程占用时，其他线程不会进入睡眠(挂起)状态，而是一直运行（自旋/空转）直到锁被释放。由于不涉及用户态与内核态之间的切换，它的效率远远高于互斥锁。</p>
<p><strong>信号量(Semaphore)</strong>，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。</p>
<p>信号量可以分为几类：</p>
<ul>
<li>二进制信号量(binary semaphore) / 二元信号量 ：只允许信号量取0或1值，，只有两种状态：占用与非占用，其同时只能被一个线程获取。</li>
<li>整型信号量（integer semaphore)：信号量取值是整数，它可以被多个线程同时获得，直到信号量的值变为0。</li>
<li>记录型信号量（record semaphore)：每个信号量s除一个整数值value（计数）外，还有一个等待队列List，其中是阻塞在该信号量的各个线程的标识。当信号量被释放一个，值被加一后，系统自动从等待队列中唤醒一个等待中的线程，让其获得信号量，同时信号量再减一。</li>
</ul>
<p>信号量通过一个计数器控制对共享资源的访问，信号量的值是一个非负整数，所有通过它的线程都会将该整数减一。如果计数器大于0，则访问被允许，计数器减1；如果为0，则访问被禁止，所有试图通过它的线程都将处于等待状态。</p>
<p><strong>条件变量</strong> （Condition Variable） 作为一种同步手段类似于栅栏，允许线程以一种无竞争的方式等待某个条件的发生。当该条件没有发生时，线程会一直处于休眠状态。当被其它线程通知条件已经发生时，线程才会被唤醒从而继续向下执行。条件变量是比较底层的同步原语，直接使用的情况不多，往往用于实现高层之间的线程同步。使用条件变量的一个经典的例子就是线程池(Thread Pool)了。</p>
</blockquote>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><blockquote>
<p>共享内存允许两个或者多个进程共享一个给定的存储区，因为数据不需要再客户即和服务器之间复制，所以共享内存是最快的一种 I IPC。使用共享内存唯一的诀窍就是多个进程之间对一给定的存储区之间数据的同步存取问题。通常，信号量被用来实现对共享存储存取的同步。（记录锁也可以用于这种场合）。</p>
<p>对于操作系统而言，在并行程序设计中难免会遇到数据同步和共享的问题，本文针对这个问题，以windows系统为例回顾一下资源同步的相关问题。</p>
<p>要点如下：</p>
<p>1.同步和数据共享数据征用</p>
<p>2.同步原语 1.互斥和临界区 2.自旋锁 3.信号量 4.读写锁 5.屏障 6.原子操作与无锁代码</p>
</blockquote>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>1、<a href="https://juejin.cn/post/6844903543527178248" target="_blank" rel="noopener">https://juejin.cn/post/6844903543527178248</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/01/04/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" data-id="cklan55jm0015z20ra36d79i2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-信号signal" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/03/%E4%BF%A1%E5%8F%B7signal/" class="article-date">
  <time datetime="2021-01-02T20:39:12.000Z" itemprop="datePublished">2021-01-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/03/%E4%BF%A1%E5%8F%B7signal/">信号signal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h1><blockquote>
<p>信号：</p>
<p>信号是一种软中断，信号提供了一种处理异步事件的方法。比如终端运行着一个程序，我们在设备输入一个ctrl+c中断停止的按键，那么我们实际上通过触发一个信号（）停止了一个程序。</p>
<p>信号的处理：</p>
<p>（1）可以直接将其忽略掉。大多数信号可以直接忽略掉但有两种信号却决不能被忽略，它们是SIGKILL和SIGSTOP信号。</p>
<p>（2）捕捉信号，注册信号处理函数。</p>
<p>（3）执行系统的默认动作。</p>
<p>进程创建：</p>
<p>当一个进程调用fork函数的时候，其子进程会直接继承父进程的信号处理方式，因为子进程在开始复制了父进程的春初对象，所以信号捕捉函数的地址在子进程中是有意义的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2021/01/03/%E4%BF%A1%E5%8F%B7signal/" data-id="cklan55jd000lz20r8cc9fi3i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试手撕代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/27/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" class="article-date">
  <time datetime="2020-12-26T16:43:58.000Z" itemprop="datePublished">2020-12-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/27/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/">手撕代码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面试常见的手撕代码题型"><a href="#面试常见的手撕代码题型" class="headerlink" title="面试常见的手撕代码题型"></a>面试常见的手撕代码题型</h1><p>所有代码都已经跑过</p>
<h2 id="经典排序"><a href="#经典排序" class="headerlink" title="经典排序"></a>经典排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 交换两个数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 冒牌排序算法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == arr)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;len-i<span class="number">-1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])</span><br><span class="line">        swap(arr[j], arr[j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">  BubbleSort(arr);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>0 1 5 7 7 7 8 8 9</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, temp;</span><br><span class="line">  <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">/* temp存放的是基数 */</span></span><br><span class="line">  temp = arr[left];</span><br><span class="line">  i = left;</span><br><span class="line">  j = right;</span><br><span class="line">  <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">    <span class="comment">/* 顺序很重要，要从右边开始找 */</span></span><br><span class="line">    <span class="keyword">while</span>(arr[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">      j--;</span><br><span class="line">    <span class="comment">/* 再从左开始找 */</span></span><br><span class="line">    <span class="keyword">while</span>(arr[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">      swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  arr[left] = arr[i];</span><br><span class="line">  arr[i] = temp;</span><br><span class="line">  </span><br><span class="line">  quickSort(left, i<span class="number">-1</span>);</span><br><span class="line">  quickSort(i+<span class="number">1</span>, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找也叫做折半查找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hight = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid, midVal;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= hight)&#123;</span><br><span class="line">        mid = (low+hight)/<span class="number">2</span>;</span><br><span class="line">        midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(midVal &lt; key)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(midVal &gt; key)</span><br><span class="line">            hight = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">-32</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">45</span>, <span class="number">59</span>, <span class="number">98</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input the data.\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line">    <span class="keyword">int</span> ret = binarySearch(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == ret)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the key %d is exits.\n"</span>, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the key %d is not exits.\n"</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义链表结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">listNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 反转链表 */</span></span><br><span class="line"><span class="function">listNode *<span class="title">reverseList</span><span class="params">(listNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == head || <span class="literal">NULL</span> == head-&gt;next)</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  listNode *cur = head;</span><br><span class="line">  listNode *prev = <span class="literal">NULL</span>;</span><br><span class="line">  listNode *next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">/* 存放下一个节点 */</span></span><br><span class="line">    next = cur-&gt;next;</span><br><span class="line">    <span class="comment">/* 翻转头结点的下一个节点 */</span></span><br><span class="line">    cur-&gt;next = prev;</span><br><span class="line">    <span class="comment">/* 移动上一个节点 */</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    <span class="comment">/* 更新当前节点 */</span></span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> prev；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==i%<span class="number">16</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断链表是否有环 */</span></span><br><span class="line"><span class="function">linkNode *<span class="title">isCircle</span><span class="params">(linkNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    linkNode *slow = head-&gt;next;               <span class="comment">/* 慢指针 */</span></span><br><span class="line">    linkNode *fast = head-&gt;next-&gt;next;         <span class="comment">/* 快指针 */</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">/* 无环 */</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> slow;    <span class="comment">/* 有环 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="实现memcpy函数"><a href="#实现memcpy函数" class="headerlink" title="实现memcpy函数"></a>实现memcpy函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不考虑内存重叠的情况 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myMemcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == dest||<span class="literal">NULL</span> == src)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> *d = (<span class="keyword">char</span> *)dest;</span><br><span class="line">  <span class="keyword">char</span> *s = (<span class="keyword">char</span> *)src;</span><br><span class="line">  <span class="keyword">while</span>(n--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优化版本按照CPU位宽度进行拷贝优化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  *<span class="title">myMemcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nchucks = num/<span class="keyword">sizeof</span>(dest);  <span class="comment">/* 按照CPU的位宽进行拷贝 */</span></span><br><span class="line">  <span class="keyword">int</span> slice = num%/<span class="keyword">sizeof</span>(dest);   <span class="comment">/* 剩余的字节数按照一个一个字节进行拷贝 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *s = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)src;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)dest;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">while</span>(nchucks--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">while</span>(slice--)</span><br><span class="line">    *((<span class="keyword">char</span>*)d++) = *((<span class="keyword">char</span>*)s++);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 考虑内存重叠的情况 */</span></span><br></pre></td></tr></table></figure>



<h3 id="实现strstr函数"><a href="#实现strstr函数" class="headerlink" title="实现strstr函数"></a>实现strstr函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">myStrstr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现strlen函数"><a href="#实现strlen函数" class="headerlink" title="实现strlen函数"></a>实现strlen函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myStrlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(arr);</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">'\0'</span> != *arr++)</span><br><span class="line">    count++;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现strcpy函数"><a href="#实现strcpy函数" class="headerlink" title="实现strcpy函数"></a>实现strcpy函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">myStrcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert(dest);</span><br><span class="line">  assert(src);</span><br><span class="line">  <span class="keyword">char</span> *d = dest;</span><br><span class="line">  <span class="keyword">char</span> *s = src;</span><br><span class="line">  <span class="keyword">while</span>(<span class="string">'\0'</span> != *s)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、<a href="https://blog.csdn.net/weixin_43496874/article/details/100868367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43496874/article/details/100868367?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control</a></p>
<p>2、<a href="http://c.biancheng.net/cpp/html/2744.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/html/2744.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/12/27/%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/" data-id="cklan55jn0018z20r7o6e6nsf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/20/docker/" class="article-date">
  <time datetime="2020-12-20T00:49:58.000Z" itemprop="datePublished">2020-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/20/docker/">docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Docker 本质上就是一个虚拟机。</p>
<p><img src="/2020/12/20/docker/image.png" alt="image-20201220085110478"></p>
<p>在docker中有几个基本的概念。</p>
<p>1、镜像：类似于平时使用的iso或者image镜像文件。</p>
<p>2、容器：容器其实就会类似于虚拟机</p>
<p>3、tar文件：类似于vmdk文件，可以直接打个包在别的地方直接run运行。</p>
<p>4、docker file。docker 的一些配置</p>
<p>5、仓库：存放有很多已经打包好的镜像，MySQL镜像、ngnix镜像等。</p>
<p>常用的操作命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1、直接从远程仓库下载mysql镜像</span><br><span class="line">docker search mysql 查找mysql镜像</span><br><span class="line">docker pull mysql   下载mysql镜像</span><br><span class="line">等价于命令docker pull mysql:latest,不指定版本会直接默认下载最新的版本镜像。</span><br><span class="line"></span><br><span class="line">2、查看本地的镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">3、运行容器</span><br><span class="line">docker run -d 3307:3306 mysql</span><br><span class="line">-d 指定后台运行不阻塞当前shell窗口</span><br><span class="line">-p 指定内外部端口映射 外部:内部</span><br><span class="line"></span><br><span class="line">4、查看正在运行的容器，查看活跃的容器。</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">5、进入容器</span><br><span class="line">docker exec -it id bash</span><br><span class="line"></span><br><span class="line">6、启动停止容器</span><br><span class="line">docker stop &lt;容器ID&gt;</span><br><span class="line">docker restart &lt;容器ID&gt;</span><br><span class="line"></span><br><span class="line">7、删除docker实例</span><br><span class="line">docker rm -f 实例ID</span><br><span class="line"></span><br><span class="line">8、查询mysql镜像</span><br><span class="line">docker search mysql</span><br><span class="line"></span><br><span class="line">9、保存容器镜像</span><br><span class="line">docker commit 实例ID 新的名字</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/20/docker/image1.png" alt="image-20201220090133527"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/12/20/docker/" data-id="cklan55jb000hz20r7h6p94xs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IO多路复用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/20/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="article-date">
  <time datetime="2020-12-20T00:25:28.000Z" itemprop="datePublished">2020-12-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/20/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>&ensp;&ensp;&ensp;&ensp;我们可以将标准输入、套接字等都看做IO的一路，多路复用的意思是在任何一路IO有事件的情况下，通知应用程序去处理相应的IO事件，这样程序就仿佛可以同一时刻处理多个IO事件了。</p>
</blockquote>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><blockquote>
<ul>
<li><p>select fd_set结构，底层是一个bitmap结构，是定长的1024，不容易改，如果需要改需要重新编译内核代码。</p>
</li>
<li><p>使用select函数，通知内核挂起进程，当一个或者多个IO事件发生之后，控制权限返回给应用程序，由应用程序进行IO事件的处理。</p>
</li>
<li><p>当有事件发生的时候，并不知道具体是哪几条流（可能有一个也可能有多个），只能轮询一遍出所有的流，找出相应的数据，或者写入数据的流，<strong>时间复杂度为O(n)</strong>。</p>
</li>
<li><p>需要维护一个存放大量fd的数据结构，当用户空间向内核空间传递该数据结构的时候会发生大量的拷贝，拷贝开销大，从而影响效率。</p>
</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfd, fd_set *readset, fd_set *writeset, fd_set *expectset, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;		<span class="comment">/* 秒 */</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;		<span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;</span><br><span class="line">timeout可以有三种情况：</span><br><span class="line">timeout == <span class="literal">NULL</span>;	<span class="comment">/* 等待无限长的时间 */</span></span><br><span class="line">timeout-&gt;tv_sec == <span class="number">0</span> &amp;&amp; timeout-&gt;tv_usec == <span class="number">0</span>	<span class="comment">/* 不等待，直接返回。（Noblock 非阻塞）*/</span></span><br><span class="line">timeout-&gt;tv_sec != <span class="number">0</span> || timeout-&gt;usec != <span class="number">0</span>	<span class="comment">/* 等待指定的时间 */</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* FD_ZERO 将一个fd_set类型的变量的所有的位都设置为0 */</span></span><br><span class="line"><span class="keyword">int</span> FD_ZERO(fd_set *fdset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_CLR 可以将某一个位进行清除 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(fd_set *fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_SET 用来将某一个位进行置位1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* FD_ISSET 用来检测某一个位是否被置位 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值（return value）:做好准备的文件描述符个数，超时为0， 错误为-1。</p>
<p>中间的三个参数readset、writeset、exepectset，分别是读描述符集合 readset、写描述符集合 writeset 和异常描述符集合 exceptset，这些参数指明了我们关心哪一些描述符，和需要满足什么条件。一个文件描述符保存在fd_set类型之中，fd_set其实就是一个位图bitmap。</p>
<p>int maxfd; 指的是最大的文件描述符加1。</p>
<p>Linux环境下编程，系统给提供了一组宏定义，可以对我们的fd_set进行赋值等操作。</p>
<p>Demo:</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"usage: select01 &lt;IPaddress&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> socket_fd = tcp_client(argv[<span class="number">1</span>], SERV_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> recv_line[MAXLINE], send_line[MAXLINE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    fd_set readmask;</span><br><span class="line">    fd_set allreads;</span><br><span class="line">    FD_ZERO(&amp;allreads);</span><br><span class="line">    FD_SET(<span class="number">0</span>, &amp;allreads);</span><br><span class="line">    FD_SET(socket_fd, &amp;allreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        readmask = allreads;</span><br><span class="line">        <span class="keyword">int</span> rc = select(socket_fd + <span class="number">1</span>, &amp;readmask, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rc &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="number">1</span>, errno, <span class="string">"select failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(socket_fd, &amp;readmask)) &#123;</span><br><span class="line">            n = <span class="built_in">read</span>(socket_fd, recv_line, MAXLINE);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="number">1</span>, errno, <span class="string">"read error"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                error(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"server terminated \n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            recv_line[n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fputs</span>(recv_line, <span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">"\n"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readmask)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(send_line, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="built_in">strlen</span>(send_line);</span><br><span class="line">                <span class="keyword">if</span> (send_line[i - <span class="number">1</span>] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    send_line[i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"now sending %s\n"</span>, send_line);</span><br><span class="line">                <span class="keyword">size_t</span> rt = <span class="built_in">write</span>(socket_fd, send_line, <span class="built_in">strlen</span>(send_line));</span><br><span class="line">                <span class="keyword">if</span> (rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="number">1</span>, errno, <span class="string">"write failed "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"send bytes: %zu \n"</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><blockquote>
<p>poll其实本质和select一样没有太大的区别，主要有几点改变。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	short events;</span><br><span class="line">	short revents;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds. <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Events可以表示多个不同的事件，具体的实现可以通过二进制掩码位操作来完成，例如<code>POLLIN</code>和<code>POLLOUT</code>表示可读可写事件。</p>
</li>
<li><p>与select不同的在于，poll每次检测之后的结果不会修改元凯的传入的值，而是将结果保留在revents字段中，这样就不用每次检测完成之后都要重置待检测的描述字和感兴趣的事件。revents可以理解<code>return events</code>。</p>
</li>
<li><p>如果对某个pollfd结构进行事件检测，可以将对应的pollfd结构的fd成员设置成一个负值，poll函数将会忽略该事件。</p>
</li>
<li><p>突破了select(1024)最大文件描述符的限制，原因是它是基于链表来存储</p>
<p><strong>同样存在缺点：</strong></p>
<p>1、依旧是大量的fd数组在用户空间和内核空间之间进行拷贝。</p>
<p>2、poll是水平触发，如果fd就绪被报告之后没有对其进行处理，下次poll韩式会再次报告该事件。</p>
</li>
</ul>
</blockquote>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li><p>epoll_create 函数是一个系统调用函数，函数将会在内核空间开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。</p>
</li>
<li><p>epoll_ctl是epoll事件的注册函数，epoll与select不同，select函数是调用时指定的需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间内，此函数是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。<br> 参数1：epfd，epoll结构的进程fd编号，函数将依靠该编号找到对应的epoll结构。<br> 参数2：op，表示当前的请求的类型，由三个定义：</p>
<pre><code>EPOLL_CTL_ADD:注册新的fd到epoll中。
EPOLL_CTL_MOD:修改已经注册的fd的监听事件。
EPOLL_CTL_DEL:从epfd中删除一个fd。</code></pre><p> 参数3：fd,需要监听的文件描述符，一般指的是sockfd。<br> 参数4：event，告诉内核该fd资源感兴趣的事件。</p>
</li>
<li><p>epoll_wait函数，等待事件的发生，类似于select()函数调用。根据参数timeout，决定是否处于阻塞模式。<br>  参数1：epfd，指定一个感兴趣事件列表。<br>  参数2：*events，是一个指针，必须指向一个epoll_event结构数组，当函数返回的时候，内核会将就绪状态的的数据拷贝到该数组中。<br>  参数3：maxevents，标明参数2epoll_event结构数组最多能接收的数据量，即本次操作做多能获取多少就绪数据。<br>  参数4: timeout，单位为毫秒。</p>
<pre><code>0：表示立即返回。
-1：阻塞调用，直到有用户感兴趣事件就绪为止。</code></pre></li>
</ul>
<p>(1) epoll_create 函数是一个系统调用函数，函数将会在内核空间开辟一块新的空间，可以理解为epoll结构空间，返回值为epoll的文件描述符编号，方便后续操作使用。</p>
<p>(2) epoll_ctl是epoll事件的注册函数，epoll与select不同，select函数是调用时指定的需要监听的描述符和事件，epoll先将用户感兴趣的描述符事件注册到epoll空间内，此函数是非阻塞函数，作用仅仅是增删改epoll空间内的描述符信息。<br>  参数1：epfd，epoll结构的进程fd编号，函数将依靠该编号找到对应的epoll结构。<br>  参数2：op，表示当前的请求的类型，由三个定义：<br>               EPOLL_CTL_ADD:注册新的fd到epoll中。<br>               EPOLL_CTL_MOD:修改已经注册的fd的监听事件。<br>               EPOLL_CTL_DEL:从epfd中删除一个fd。<br>  参数3：fd,需要监听的文件描述符，一般指的是sockfd。<br>  参数4：event，告诉内核该fd资源感兴趣的事件。</p>
<p>(3)epoll_wait函数，等待事件的发生，类似于select()函数调用。根据参数timeout，决定是否处于阻塞模式。<br>  参数1：epfd，指定一个感兴趣事件列表。<br>  参数2：*events，是一个指针，必须指向一个epoll_event结构数组，当函数返回的时候，内核会将就绪状态的的数据拷贝到该数组中。<br>  参数3：maxevents，标明参数2epoll_event结构数组最多能接收的数据量，即本次操作做多能获取多少就绪数据。<br>  参数4: timeout，单位为毫秒。<br>         0 表示立即返回。</p>
<p>​        -1 阻塞调用，直到有用户感兴趣事件就绪为止。</p>
<p>​        &gt;0 阻塞调用，阻塞指定的时间内如果有时间就绪则是提前返回，否则就等待指定的事件后返回。<br>  返回值（return value）：本次就绪的fd的个数。</p>
<p>工作模式：<br>       epoll对文件描述符的操作有两种模式：LT(水平触发)和ET(边缘触发)。LT是默认模式，两者的区别如下：<br>       LT(level 水平触发)：事件就绪之后，用户可以选择处理或者不处理，如果用户本次未进行处理，那么下次调用epoll_wait时候仍然会将未出的事件打包给你。<br>       ET(edge 边缘触发)： 事件就绪之后，用户必须处理，因为内核不给给你兜底，内核把就绪的事件打包给用户态之后，就会把对应的就绪事件清理掉，不会再次通知用户。<br>       ET模式在很大的程度上减少了epoll事件被重复触发的次数，因此被认为效率比LT模式高，也是epoll重要的杀手锏。</p>
<p><strong>epoll优点：</strong></p>
<p>1、没有最大文件描述符限制</p>
<p>2、使用mmap文件映射内存加速与内核空间的消息传递，不再是大量的fd从用户空间拷贝到内核空间，大大减少了拷贝的开销。</p>
<p>3、效率提升，不再使用轮询</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>1、<a href="https://blog.csdn.net/qq_35976351/article/details/85228002" target="_blank" rel="noopener">https://blog.csdn.net/qq_35976351/article/details/85228002</a></p>
<p>2、<a href="https://time.geekbang.org/column/article/138948" target="_blank" rel="noopener">https://time.geekbang.org/column/article/138948</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.lpyuan.club/2020/12/20/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" data-id="cklan55j40005z20r4hpo6ojm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Unix%E7%8E%AF%E5%A2%83%E7%BC%96%E7%A8%8B/">Unix环境编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows/">windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/">面试宝典</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/18/Linux%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84EAGIN%E5%BC%82%E5%B8%B8/">Linux非阻塞模式下的EAGIN异常</a>
          </li>
        
          <li>
            <a href="/2021/01/07/Raft%E7%AE%97%E6%B3%95/">Raft算法</a>
          </li>
        
          <li>
            <a href="/2021/01/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
          </li>
        
          <li>
            <a href="/2021/01/07/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/">海量数据处理问题</a>
          </li>
        
          <li>
            <a href="/2021/01/06/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90/">结构体对齐</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 发量充足的程序员<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>